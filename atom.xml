<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ThinerZQ&#39;s Blog</title>
  <subtitle>酷爱历史文学的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thinerzq.com/"/>
  <updated>2016-09-09T01:53:57.444Z</updated>
  <id>http://thinerzq.com/</id>
  
  <author>
    <name>Monet Zheng</name>
    <email>601097836@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <link href="http://thinerzq.com/2016/09/09/leetcode/102-Binary-Tree-Level-Order-Traversal/"/>
    <id>http://thinerzq.com/2016/09/09/leetcode/102-Binary-Tree-Level-Order-Traversal/</id>
    <published>2016-09-09T01:26:34.000Z</published>
    <updated>2016-09-09T01:53:57.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>
<pre>
3
/ \
9  20
 /  \
15   7
</pre>

<p>return its level order traversal as:</p>
<pre>
[
  [3],
  [9,20],
  [15,7]
]
</pre>

<a id="more"></a>
<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用队列，每次将一层加入到当前队列。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>全部代码<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created with IntelliJ IDEA</div><div class="line"> * Date: 2016/3/4</div><div class="line"> * Time: 19:50</div><div class="line"> * User: ThinerZQ</div><div class="line"> * GitHub: &lt;a&gt;https://github.com/ThinerZQ&lt;/a&gt;</div><div class="line"> * Blog: &lt;a&gt;http://www.thinerzq.me&lt;/a&gt;</div><div class="line"> * Email: 601097836@qq.com</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversal_102</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        TreeNode treeNode = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</div><div class="line">        levelOrder(treeNode);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">        <span class="comment">//null的处理</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回值</span></div><div class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="comment">//层次遍历所需要的队列</span></div><div class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">        <span class="comment">//root 不为空，将root加入队列中</span></div><div class="line">        queue.add(root);</div><div class="line">        <span class="comment">//如果队列不为空</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="comment">//保存当前对别中的所有节点</span></div><div class="line">            ArrayList&lt;TreeNode&gt; treeNodes = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</div><div class="line">            <span class="comment">//保存当前队列中所有节点的值</span></div><div class="line">            ArrayList&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">            <span class="comment">//取出当前队列中的所有节点</span></div><div class="line">            Iterator&lt;TreeNode&gt; iterator = queue.iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                TreeNode temp = iterator.next();</div><div class="line">                treeNodes.add(temp);</div><div class="line">                vals.add(temp.val);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//将当前队列中的所有值最为一个list加入到 返回值列表</span></div><div class="line">            lists.add(vals);</div><div class="line">            <span class="comment">//当前队列清空</span></div><div class="line">            queue.clear();</div><div class="line">            <span class="comment">//将treeNodes中保存的当前队列中的所有值的左节点和右节点 进行判断。</span></div><div class="line">            <span class="keyword">for</span> (TreeNode treeNode : treeNodes) &#123;</div><div class="line">                TreeNode temp = treeNode;</div><div class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</div><div class="line">                    queue.add(temp.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</div><div class="line">                    queue.add(temp.right);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lists;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line"></div><div class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</div><div class="line">            val = x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;
3
/ \
9  20
 /  \
15   7
&lt;/pre&gt;

&lt;p&gt;return its level order traversal as:&lt;/p&gt;
&lt;pre&gt;
[
  [3],
  [9,20],
  [15,7]
]
&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://thinerzq.com/categories/leetcode/"/>
    
    
      <category term="leetcode tree Breadth-first Search" scheme="http://thinerzq.com/tags/leetcode-tree-Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>102 Pascal&#39;a Triangle</title>
    <link href="http://thinerzq.com/2016/09/08/leetcode/118-Pascal&#39;s%20Triangle/"/>
    <id>http://thinerzq.com/2016/09/08/leetcode/118-Pascal&#39;s Triangle/</id>
    <published>2016-09-08T13:08:06.000Z</published>
    <updated>2016-09-09T01:25:00.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5</p>
<p>Return</p>
<p><pre>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]<br></pre><br><a id="more"></a></p>
<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每一行除了第0个元素和最后一个元素除外，current[j] = lastRow[j-1]+lastRow[j];</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</div><div class="line">        <span class="comment">//防御式编程</span></div><div class="line">        <span class="keyword">if</span> (numRows == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//最终返回结果</span></div><div class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="comment">//加入第一行元素</span></div><div class="line">        ArrayList&lt;Integer&gt; first = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        first.add(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">        lists.add(<span class="number">0</span>, first);</div><div class="line">        <span class="comment">//对接下来的每一行，取出上一行</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</div><div class="line">            <span class="comment">//templist 是arraylist，可以保持加入的顺序</span></div><div class="line">            List&lt;Integer&gt; tempLists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">            <span class="comment">//取出上一行</span></div><div class="line">            List&lt;Integer&gt; preList = lists.get(i - <span class="number">1</span>);</div><div class="line">            <span class="comment">//在templist 上插入第0个元素：1，</span></div><div class="line">            tempLists.add(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">            <span class="comment">// int len = (i)/2+1;</span></div><div class="line">            <span class="comment">//本行的第j个元素 = 上一行的第j-1个元素 + 上一行的第j个元素 ， 1&lt;=j&lt;i</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</div><div class="line">                tempLists.add(j, preList.get(j - <span class="number">1</span>) + preList.get(j));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//在templist 中Haru最后一个元素：1</span></div><div class="line">            tempLists.add(<span class="number">1</span>);</div><div class="line">            lists.add(i, tempLists);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lists;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;given numRows, generate the first numRows of Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given numRows = 5&lt;/p&gt;
&lt;p&gt;Return&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;[&lt;br&gt;     [1],&lt;br&gt;    [1,1],&lt;br&gt;   [1,2,1],&lt;br&gt;  [1,3,3,1],&lt;br&gt; [1,4,6,4,1]&lt;br&gt;]&lt;br&gt;&lt;/pre&gt;&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://thinerzq.com/categories/leetcode/"/>
    
    
      <category term="leetcode array" scheme="http://thinerzq.com/tags/leetcode-array/"/>
    
  </entry>
  
  <entry>
    <title>mysql win64 5.7.9 zip包安装日记</title>
    <link href="http://thinerzq.com/2016/09/01/mysql%20win64%205.7.9%20zip%E5%8C%85%E5%AE%89%E8%A3%85%E6%97%A5%E8%AE%B0/"/>
    <id>http://thinerzq.com/2016/09/01/mysql win64 5.7.9 zip包安装日记/</id>
    <published>2016-09-01T02:52:20.000Z</published>
    <updated>2016-09-04T07:34:51.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官网下载win64-zip包"><a href="#官网下载win64-zip包" class="headerlink" title="官网下载win64 zip包"></a>官网下载win64 zip包</h1><p>找到合适的目录解压</p>
<h1 id="配置my-default-ini"><a href="#配置my-default-ini" class="headerlink" title="配置my-default.ini"></a>配置my-default.ini</h1><blockquote>
<p>basedir = D:\Study\MySQL\mysql-5.7.14-server-win64<br> datadir = D:\Study\MySQL\mysql-5.7.14-server-win64\data<br> port = 3306</p>
</blockquote>
<p> #管理员方式打开命令行，进入mysql home 目录下的bin目录</p>
<p>执行如下命令：</p>
<blockquote>
<ol>
<li>mysqld –initialize（我使用mysqld –initialize -secure生成的data目录下的文件不完整）<br>在mysql的根目录下自动生成data目录以及其他文件，初始化一个随机密码的root用户</li>
<li>mysqld -install/remove<br>注册mysql服务</li>
<li>net start/stop mysql<br>启动服务</li>
</ol>
</blockquote>
<h1 id="关于root的随机密码在那里"><a href="#关于root的随机密码在那里" class="headerlink" title="关于root的随机密码在那里"></a>关于root的随机密码在那里</h1><p>windows在data目录下的DESKTOP-M03IEJ5.err文件里面，搜索“2016-09-01T02:15:22.399996Z 1 [Note] A temporary password is generated for root@localhost: -/br&gt;,B;o9gm”这样的一个字符串就能找到了，其他系统也都写在日志里面，找找总会有的</p>
<h1 id="最后-mysql-u-root-p-password-进入mysql-控制台"><a href="#最后-mysql-u-root-p-password-进入mysql-控制台" class="headerlink" title="最后:mysql -u root -p password 进入mysql 控制台"></a>最后:mysql -u root -p password 进入mysql 控制台</h1><p>更改mysql密码</p>
<blockquote>
<p>alter user ‘root’@’localhost’ identified by ‘your password’;</p>
</blockquote>
<p>that’s all</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;官网下载win64-zip包&quot;&gt;&lt;a href=&quot;#官网下载win64-zip包&quot; class=&quot;headerlink&quot; title=&quot;官网下载win64 zip包&quot;&gt;&lt;/a&gt;官网下载win64 zip包&lt;/h1&gt;&lt;p&gt;找到合适的目录解压&lt;/p&gt;
&lt;h1 id=&quot;
    
    </summary>
    
      <category term="mysql" scheme="http://thinerzq.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://thinerzq.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>战国纵横</title>
    <link href="http://thinerzq.com/2016/08/27/history/%E6%88%98%E5%9B%BD%E7%BA%B5%E6%A8%AA/"/>
    <id>http://thinerzq.com/2016/08/27/history/战国纵横/</id>
    <published>2016-08-27T01:08:47.000Z</published>
    <updated>2016-08-27T04:21:29.818Z</updated>
    
    <content type="html"><![CDATA[<p>乱世总有英雄，奇人，最早的乱世莫过于春秋战国。</p>
<p>庞涓，孙膑，苏秦，张仪，纵横捭阖。以前对这段历史充满了向往，总是一直没时间看，终于借助这两个月的上下班时间熟悉了一下这段历史，记录一下，留个印象。</p>
<p>还是从周朝说起，西周末年，周氏衰落，天子雄风不在，天下早已礼崩乐坏，各路诸侯明着都尊周天子，实际上都在谋划着如何除掉其他诸侯，如何称王。</p>
<a id="more"></a>
<h1 id="主人公登场"><a href="#主人公登场" class="headerlink" title="主人公登场"></a>主人公登场</h1><p>魏惠王借天子之名，邀天下诸侯前往孟津朝王，但是秦孝公不停商鞅的话没去，然后魏惠王就借机联合其他诸侯攻打秦国，秦孝公想决战，但是商鞅不让，最后商鞅去魏国求和，并把秦孝公的女儿嫁给了魏惠王的儿子公子昂，并借机扶持上大夫陈轸，最后求和成功，并且鼓动魏惠王称王（因为这时候魏国最强，前任魏文侯任用吴起为将，用XX为相，是所有国家中最早变法的），魏惠王煞笔停了陈珍的话要称王（陈珍把庞涓的父亲抓起来给皇帝做龙袍，最后加害了他，庞涓出逃），广发英雄帖，邀请天下诸侯，最后在XX地方举行称王仪式的时候之后秦国的太子来了，其他国家都没来，面子上过去不去啊，就调了一个最弱的国家“卫国”，派兵去打，卫国肯定不愿意了（不愿意也要打啊，最后魏国攻破平阳，孙膑一家其他人全部战死），打不过只能去齐国，楚国请救兵，齐国，楚国出兵了，不过只是来看看有没有便宜可以捞，魏惠王听到这两个国家出兵就把镇守河西的兵力都调过来要教训一下这两只猴子，最后秦国趁机占领河西，魏惠王吓了一跳，马上找陈珍去和齐，楚议和。最后什么好处没捞着，便宜了秦国，魏惠王回去之后一心要伐秦，最后和秦军决战河西，主将为他儿子公子昂，秦国用商鞅为主将，司马错为副将，把公子昂耍的团团转，最后损并十几万败走河西（张仪家是魏国的小军官，张仪家就遭殃了，不过张仪这个时候被送去周天子所在城市洛阳求学去了）。魏国元气大伤，秦国士气大振，秦公听过商鞅的意见给儿子说门亲事，让上大夫樗里疾带着聘礼去聘娶周天子的女儿，魏国得到消息也要去聘周天子的女儿，周天子只有听别人话的份，这个时候墨家巨子给周天子的皇后支招，求鬼谷子出山，（这个时候苏秦结巴出场了，最开始偷听世子们弹琴被打了，不过被周天子的女儿给救了，话说从这个时候苏秦交上好运了，偶然间在一个破庙里遇见了鬼谷子），最后鬼谷子带着皇后的女儿姬雪（玉蝉儿）回山修行，并赠与苏秦治疗结巴的秘书。第一话告一段落了，四位牛逼的人都出场了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;乱世总有英雄，奇人，最早的乱世莫过于春秋战国。&lt;/p&gt;
&lt;p&gt;庞涓，孙膑，苏秦，张仪，纵横捭阖。以前对这段历史充满了向往，总是一直没时间看，终于借助这两个月的上下班时间熟悉了一下这段历史，记录一下，留个印象。&lt;/p&gt;
&lt;p&gt;还是从周朝说起，西周末年，周氏衰落，天子雄风不在，天下早已礼崩乐坏，各路诸侯明着都尊周天子，实际上都在谋划着如何除掉其他诸侯，如何称王。&lt;/p&gt;
    
    </summary>
    
      <category term="history" scheme="http://thinerzq.com/categories/history/"/>
    
    
      <category term="history 春秋战国" scheme="http://thinerzq.com/tags/history-%E6%98%A5%E7%A7%8B%E6%88%98%E5%9B%BD/"/>
    
  </entry>
  
  <entry>
    <title>Tair学习</title>
    <link href="http://thinerzq.com/2016/07/28/tair%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/28/tair学习报告/</id>
    <published>2016-07-28T01:08:06.000Z</published>
    <updated>2016-08-14T14:38:23.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先tair是一个的Key-Value结构分布式存储系统，既可以做高速缓存，也可以做持久化存储。分布式系统一般来说是一个集群，而在Tair的集群中主要存在如下几个模块：</p>
<p><strong>ConfigServer</strong><br>一个集群中包含2台configserver,两台configserver互为主备。</p>
<ol>
<li>维护和dataserver之间的心跳获得集群中存活可用的dataserver</li>
<li>根据存活的dataserver 构建数据在集群中的分布信息（对照表）</li>
<li>对client提供分部信息（对照表）的查询</li>
<li>当dataserver挂掉，或者新添加dataserver的时候，调度各个dataserver完成数据的迁移，复制</li>
</ol>
<p><strong>DataServer</strong><br>真正存放数据的地方</p>
<ol>
<li>提供数据存储服务，接受client端的put/get/remove操作。</li>
<li>执行数据迁移复制</li>
</ol>
<p><strong>InvalidServer</strong><br>InvalidServer是一个可选模块，</p>
<ol>
<li>接收来自client的invalid/hide请求，对属于同一组的集群（双机房独立集群部署方式）做delete/hide操作，保证同一组集群的一致。</li>
</ol>
<p><strong>Client</strong><br>Tair提供出来的SDK</p>
<ol>
<li>在应用端提供访问Tair集群的接口。</li>
<li>和ConfigServer通信，更新并缓存数据分布表和invalidserver地址等。</li>
<li>LocalCache，避免过热数据访问影响tair集群服务。</li>
</ol>
<p>在启动时，Client会根据本地的配置文件与ConfigServer通信。Client从Config Servcer处获得可用的DataServer地址，然后Client从这些DataServer获取真正的数据。<br><a id="more"></a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>集群</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">集群</th>
<th style="text-align:left">概述</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">双机房单集群单份(Dss)</td>
<td style="text-align:left">一个Tiar实例部署在两个机房中，被单个配置服务器管理，逻辑上为单集群，数据存储份数为1</td>
<td style="text-align:left">1. 服务器存在于双机房，任一机房宕机保持可用。<br><br>2. 单份数据，无论应用在哪个机房，看到的都是同一个数据。</td>
<td style="text-align:left">1. 应用服务器会跨机房访问。<br><br>2. 当一边机房出现故障时，tair中的数据会丢失</td>
</tr>
<tr>
<td style="text-align:left">双机房单集群双份(Dsd)</td>
<td style="text-align:left">一个Tair实例部署在2个机房中，数据保存2份，并且同一数据的2个备份不会放在同一个数据服务器上</td>
<td style="text-align:left">1. 数据存放两份，数据安全性有一定保障。但由于存储引擎是mdb，数据存放在内存中，无法绝对保证数据不丢失。<br><br>2. 当一边机房故障时，另外一边机房依然可以服务，并且数据不丢失。</td>
<td style="text-align:left">如果机房间网络出现异常情况，依然有较小几率丢失数据。</td>
</tr>
<tr>
<td style="text-align:left">双机房独立集群(Dds)</td>
<td style="text-align:left">在两个机房中同时部署2个独立的集群，这两个集群直接没有直接关系。一般作为缓存使用，Tair不保证数据的一致性. 通过一个InvalidServer来保障同一个key在两个机房是一致的</td>
<td style="text-align:left">1. 每个机房拥有独立Tair集群，应用在哪个机房就访问相同机房的Tair集群，不会出现跨机房调用和流量。</td>
<td style="text-align:left">1. 后端必须要有数据源，也就是这种部署方式下，Tair必然是当作传统意义上的cache存在的。因为Tair mdb集群之间本身不会做数据同步，多集群间一致性保证依赖于后端数据源，如DB。<br><br>2. 当后端数据源数据发生更新后，业务不能直接把数据put到Tair，而是先需要调用invalid接口来失效这些对等集群中的数据</td>
</tr>
<tr>
<td style="text-align:left">双机房主备集群(Ddsm)</td>
<td style="text-align:left">这种部署方式中，存在一个主集群和一个备份集群，分别在两个机房中。数据同步由主集群透明完成。</td>
<td style="text-align:left">1. 数据安全和服务可用性高。 <br><br>2. 用户调用方便，无需考虑多集群间数据一致性的问题。</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p><strong>引擎</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">引擎</th>
<th style="text-align:left">应用场景</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mdb</td>
<td style="text-align:left">缓存，容量小，读写qps高</td>
<td style="text-align:left">支持分层key，mdb特别注意部署方式（Dss,Dds）</td>
</tr>
<tr>
<td style="text-align:left">rdb</td>
<td style="text-align:left">缓存，容量小，读写qps高</td>
<td style="text-align:left">比mdb的存储结构更加丰富（list/map/set/zset）</td>
</tr>
<tr>
<td style="text-align:left">ldb</td>
<td style="text-align:left">持久化，读写qps高</td>
<td style="text-align:left">成本比mdb,rdb高，支持范围查找（少用）</td>
</tr>
</tbody>
</table>
<p><strong>集群与引擎的对照关系</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">双机房单集群单份</th>
<th style="text-align:left">双机房单集群双份</th>
<th style="text-align:left">双机房独立集群</th>
<th style="text-align:left">双机房主备集群</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mdb</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">rdb</td>
<td style="text-align:left">√</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ldb</td>
<td style="text-align:left">√</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">√</td>
</tr>
</tbody>
</table>
<p><strong>其他基础概念</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">基础概念</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">namespace</td>
<td style="text-align:left">又称area,隔离多个应用，各个namespace对应的应用中的数据是相互隔离的</td>
</tr>
<tr>
<td style="text-align:left">quota</td>
<td style="text-align:left">对应了每个namespace储存区的大小限制，超过配额后数据将面临最近最少使用（LRU）的淘汰</td>
</tr>
<tr>
<td style="text-align:left">expireTime</td>
<td style="text-align:left">是指数据的过期时间，当超过过期时间之后，数据将对应用不可见，这个设置同样影响到应用的命中率和资源利用率</td>
</tr>
<tr>
<td style="text-align:left">version</td>
<td style="text-align:left">Tair中存储的每个数据都有版本号，版本号在每次更新后都会递增</td>
</tr>
<tr>
<td style="text-align:left">delete and invalid</td>
<td style="text-align:left">删除仅作用于一个机房数据，而失效针对多个机房。失效操作由专门的失效服务器处理，它不保证数据 立即被删除，但是保证不会被获取到</td>
</tr>
<tr>
<td style="text-align:left">LocalCache</td>
<td style="text-align:left">在客户端的cache,为了减轻dataserver负担，使用了net.sf.ehcache</td>
</tr>
</tbody>
</table>
<h1 id="分布式一致性hash"><a href="#分布式一致性hash" class="headerlink" title="分布式一致性hash"></a>分布式一致性hash</h1><p>若tair采用普通哈希即让key对机器数count取模决定key存放的机器，但当某台机器故障或增加机器时count发生变化，则原来key对应的机器发生变化，因此需要移动大量的数据。目前为了使移动的数据少一点，主要<a href="http://www.blogjava.net/hao446tian/archive/2013/01/29/394858.html" target="_blank" rel="external">采用一致性hash算法</a>来解决问题。在这里Tair使用改进的一致性hash算法来解决这个问题：<br>设有一个有限域（0-2^32）个整数，将其首尾相连形成一个环，如下图所示。<br><img src="http://img4.tbcdn.cn/L1/461/1/bf857946fd33f7d811cbe190698196b013fcb67a" alt="tair"><br>一致性哈希算法大致流程如下：</p>
<ol>
<li>将dataserver根据hash函数映射到环上。</li>
<li>将bucket根据hash函数映射到换上；从bucket在环的位置开始顺时针找到第一个桶，这就是该桶所在的dataserver。</li>
<li>据key根据hash函数映射到环上，从key在环的位置开始顺时针找到第一个桶，这就是key存放的桶。</li>
<li>当某台机器坏掉时，key对应的桶映射不会变；类似2，沿着桶顺时针找到下一台机器，这就是存放该桶所在的dataserver</li>
<li>当增加dataserver时，将该dataserver与前一台dataserver(逆时针)之间的bucket存储在新增dataserver上并从原来dataserver上移除。</li>
</ol>
<p>显然采用这种方法当机器数目发生变化时只需移动少量的数据桶。以上纯属yy，参考自：<a href="http://www.atatech.org/articles/45240" target="_blank" rel="external">http://www.atatech.org/articles/45240</a>，ATA上讲Tair分布式一致性hash的就这一个。如有错误，请指正。</p>
<h1 id="创建对照表"><a href="#创建对照表" class="headerlink" title="创建对照表"></a>创建对照表</h1><h2 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h2><p>Tair使用改进后的一致性hash算法来确保数据在数据服务器上趋于均匀分布，同时获取良好的可扩展性。Tair将数据按bucket为单位，存放在存储节点上，每一个节点可以存储多个bucket。对于每一个bucket而言，可能会存在多个备份。若在多备份的情况下，其中一个bucket称为master bucket,其他的称为slave bucket。Tair客户端会从configserver获取到一张表，该表记录了每一个bucket存储的节点的地址。这张表称之为对照表，如下表所示。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Bucket Id</th>
<th style="text-align:left">DataServer Ip</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">192.168.0.1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">192.168.0.2</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">192.168.0.1</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">192.168.0.2</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">192.168.0.1</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">192.168.0.2</td>
</tr>
</tbody>
</table>
<p>简单的说，Tair Client 根据要put/get/remove 的key值做hash 映射到对应的bucket id ，然后根据对照表找到bucket id 对应的 dataserver ,然后和对应的dataserver进行数据交换。在这个过程中bucket的数量是固定的，也就是说key – bucket 之间的映射是固定的。 但是bucket – dataserver之间的映射却可能会发生变化：扩容，缩容，dataserver宕机等，因此需要在存活的dataserver数量发生变化的时候重建对照表，而且这个重建的过程必须对client透明。下面简单分析一下对照表的重建过程，和bucket数据迁移过程。</p>
<h2 id="对照表重建"><a href="#对照表重建" class="headerlink" title="对照表重建"></a>对照表重建</h2><p>这里先忽略对照表的初始化创建过程，假设现在有一张对照表如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">hash_table</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">m_hash_table</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">d_hash_table</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">D</td>
<td style="text-align:left">D</td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
<td style="text-align:left"></td>
<td style="text-align:left">D</td>
<td style="text-align:left">D</td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
<td style="text-align:left"></td>
<td style="text-align:left">D</td>
<td style="text-align:left">D</td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">C</td>
<td style="text-align:left">C</td>
<td style="text-align:left">C</td>
<td style="text-align:left">D</td>
<td style="text-align:left">B</td>
<td style="text-align:left"></td>
<td style="text-align:left">C</td>
<td style="text-align:left">C</td>
<td style="text-align:left">C</td>
<td style="text-align:left">D</td>
<td style="text-align:left">B</td>
<td style="text-align:left"></td>
<td style="text-align:left">C</td>
<td style="text-align:left">C</td>
<td style="text-align:left">C</td>
<td style="text-align:left">D</td>
<td style="text-align:left">B</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">B</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
<td style="text-align:left">C</td>
<td style="text-align:left">D</td>
<td style="text-align:left"></td>
<td style="text-align:left">B</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
<td style="text-align:left">C</td>
<td style="text-align:left">D</td>
<td style="text-align:left"></td>
<td style="text-align:left">B</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
<td style="text-align:left">C</td>
<td style="text-align:left">D</td>
</tr>
</tbody>
</table>
<p>其中：1，2，3，4，5表示有5个bucket。 1，2，3表示每一个bucket，冗余了三份数据,第一行的数据是master bucket,其他行是 salve bucket。A,B,C,D表示有4台dataserver。比如说hash_table表第一行第一列的D 表示：bucket 1作为master bucket 存放在dataserver D上。</p>
<p>通常有三张对照表：hash_table , m_hash_table, d_hash_table.通常情况下，这些对照表的内容相同的。只有在对照表重建后，并且有限的时间内，这些表内容不同。当重建对照表后，系统会触发数据迁移工作。待数据迁移完成后，这3张对照表内容就相同了。也就是说，只有在数据迁移过程中，对照表的内容才会不同。</p>
<p> 对照表创建后，configserver会将hash_table表发送给Client，Clietn通过这个对照表读写数据，不至于在对照表重建过程中，无法提供服务。Configserver会将m_hash_table和d_hash_table发送到dataserver, dataserver通过这两个表来确定2件事：1）自己负责存储的bucket id；2)确定迁移的bucket id以及迁移的目标机器。</p>
<p> 假设现在Dataserver D挂了，ConfigServer通过心跳包检测出来了，现在需要重建对照表。对照表的重建可以有两种策略：负载均衡有限，位置安全优先。</p>
<p> 负载均衡优先：<br> 在该策略下，构建出的对照表期望达到的效果——使得每一个节点分配的bucket数量尽可能的均衡。</p>
<h3 id="1-根据当前m-hash-table表，统计出每一个alive节点上存储的bucket数量"><a href="#1-根据当前m-hash-table表，统计出每一个alive节点上存储的bucket数量" class="headerlink" title="1: 根据当前m_hash_table表，统计出每一个alive节点上存储的bucket数量"></a>1: 根据当前m_hash_table表，统计出每一个alive节点上存储的bucket数量</h3><table>
<thead>
<tr>
<th style="text-align:left">alive dataserver</th>
<th style="text-align:left">目前存储的bucket数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">5</td>
</tr>
</tbody>
</table>
<h3 id="2-根据-1-中生成的map-得到下表，即对于hold相同数量bucket的节点存放在同一列表里"><a href="#2-根据-1-中生成的map-得到下表，即对于hold相同数量bucket的节点存放在同一列表里" class="headerlink" title="2: 根据 1) 中生成的map,得到下表，即对于hold相同数量bucket的节点存放在同一列表里"></a>2: 根据 1) 中生成的map,得到下表，即对于hold相同数量bucket的节点存放在同一列表里</h3><table>
<thead>
<tr>
<th style="text-align:left">存储bucket的数量</th>
<th style="text-align:left">存储这些数量bucket的 dataserver</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">{A}</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">{B}</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">{C}</td>
</tr>
</tbody>
</table>
<p>这里咋一看就是把1）中的表反过来了，其实不然，如果1)中的表还有一个E=2，那么2）中的表就是 2 = {A,E};</p>
<h3 id="3-给每一个节点分配存储bucket的数量。"><a href="#3-给每一个节点分配存储bucket的数量。" class="headerlink" title="3: 给每一个节点分配存储bucket的数量。"></a>3: 给每一个节点分配存储bucket的数量。</h3><p>这一步只是确定每一个节点上可以储存多少个bucket,而不确定到底存储哪一些bucket。对于不同的构建对照表策略，这一步骤是不同的。<br>在负载均衡策略下，这一步的目的就是让各个bucket尽量平均分配到各个alive dataserver，同时也要保证master bucket 也尽可能平均分配在每一个dataserver上，最后得到每一个dataserver最终要存储的bucket 总数。这里说的比较简单，详细怎么分配，可以参考：<a href="http://www.atatech.org/article/detail/6365/418" target="_blank" rel="external">http://www.atatech.org/article/detail/6365/418</a>。</p>
<h3 id="4-计算每一个节点预期可存储bucket的数量；"><a href="#4-计算每一个节点预期可存储bucket的数量；" class="headerlink" title="4: 计算每一个节点预期可存储bucket的数量；"></a>4: 计算每一个节点预期可存储bucket的数量；</h3><p>有了1) ~ 3)步的数据，现在可以计算每一个节点还可以存储的bucket的数量。    </p>
<h3 id="5-快速创建对照表。在这个步骤中，系统将hash-table的第1行（master-bbucket）中失效了的dataserver-替换掉。"><a href="#5-快速创建对照表。在这个步骤中，系统将hash-table的第1行（master-bbucket）中失效了的dataserver-替换掉。" class="headerlink" title="5: 快速创建对照表。在这个步骤中，系统将hash_table的第1行（master bbucket）中失效了的dataserver 替换掉。"></a>5: 快速创建对照表。在这个步骤中，系统将hash_table的第1行（master bbucket）中失效了的dataserver 替换掉。</h3><p>怎么替换，替换成什么？将对应bucket的slave bucket的dataserver存储到第1行相应位置（slave bucket选为master bucket）。此时，该bucket对应的所有slave bucket所在的dataserver都可以被选择，但是需要确保：选择的dataserver上负载的master bucket不能超标（因为master bucket也需要尽可能均匀分布），并且总bucket数没有超标（因为所有的bucket都要尽可能均匀分布）。替换后，将slave bucket对应的存储节点置 null。这步骤生成的表作为新对照表的hash_table和m_hash_table对照表的内容。</p>
<h3 id="6-确定每一个bucket的存储位置。"><a href="#6-确定每一个bucket的存储位置。" class="headerlink" title="6: 确定每一个bucket的存储位置。"></a>6: 确定每一个bucket的存储位置。</h3><p>首先，为master bucket安排存储节点。对于每一个master bucket当前所在的节点X，检查X节点是否满足要求。若不满足要求，则在该bucket的所有slave bucket中选择一个bucket,将该bucket作为master bucket（这里有可能选择不到，即时存在slave bucket,也无法选择。因为，要保证该slave bucket所在的dataserver上的总master bucket的数量不要超过一个值);若没有找到，则需要在alive的节点列表中，选择一个合适的节点S。将S节点作为这个master bucket的存储节点。更新统计数据。（这一步和第五步快速创建对照表似乎有重复地方，为了和后面的更新slave bucket做一个对比，在这里啰嗦一点）。以之前的表为例，其中Dataserver D 宕机了，重建的的hash_table和m_hash_table如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">hash_table</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">m_hash_table</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
<td style="text-align:left"></td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"></td>
<td style="text-align:left">C</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">B</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">C</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">B</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">B</td>
<td style="text-align:left"></td>
<td style="text-align:left">A</td>
<td style="text-align:left">C</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">B</td>
<td style="text-align:left"></td>
<td style="text-align:left">A</td>
<td style="text-align:left">C</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>其次，为slave bucket安排存储节点。具体步骤为，首先检查bucket当前的存储节点是否满足要求（若该节点down掉了，显然不满足要求了）。若不满足要求，为其选择一个合适的节点，将该节点作为bucket的存储节点。更新统计数据。这个步骤生成的对照表，作为d_hash_table的内容。</p>
<table>
<thead>
<tr>
<th style="text-align:left">d_hash_table</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><strong>A</strong></td>
<td style="text-align:left">C</td>
<td style="text-align:left"><strong>C</strong></td>
<td style="text-align:left"><strong>B</strong></td>
<td style="text-align:left">B</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">B</td>
<td style="text-align:left"><strong>A</strong></td>
<td style="text-align:left">A</td>
<td style="text-align:left">C</td>
<td style="text-align:left"><strong>C</strong></td>
</tr>
</tbody>
</table>
<p>目前看来：d_hash_table中各个dataserver的对应的bucket和master bucket 分配表比较均匀如下图所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">dataserver</th>
<th style="text-align:left">总的bucket数量</th>
<th style="text-align:left">master bucket数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">5</td>
<td style="text-align:left">1(和别的dataserver相差1，是在所难免的)</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">B</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">5</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<p>bucket分配到dataserver上满足的规则大致如下：</p>
<ol>
<li>master bucket必须均匀的分布在各个dataserver上</li>
<li>总的bucket 也必须均匀的分布在各个dataserver上</li>
<li>在满足以上两个条件的基础上，slave bucket 升级为 master bucket。</li>
</ol>
<h3 id="7-对照表同步"><a href="#7-对照表同步" class="headerlink" title="7: 对照表同步"></a>7: 对照表同步</h3><p>首先，configserver会将d_hash_table（不出意外，这就是最新的对照表）的内容保存到本地磁盘上。</p>
<p>其次，根据配置信息（是否允许数据迁移，是否允许数据丢失）。若无需数据迁移，那么用d_hash_table替换m_hash_table, hash_table。若需要数据迁移，统计哪些节点需要数据迁移。并且，将m_hash_table, hash_table保存在本地磁盘。最后，将对照表同步到备configserver上。</p>
<p>经过上述7个步骤，对照表就创建完成了。若存在数据迁移，这3个对照表内容是不同的。随着迁移的完成，3张对照表内容会变成相同的。</p>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>当可用dataserver发生变化后，configserver会重建对照表。每次创建对照表会输出3张表，将m_hash_table(描述当前 bucket分布的对照表），和d_hash_table(描述迁移完成后的bucket分布的对照表）通过心跳机制发给每一个dataserver节点。dataserver节点在收到对照表后，会对对照表的版本作检查。若检测到心跳信息中的对照表版本大于本地保存的对照表版本数（对照表版本数是依次递增的）， 会启动一个线程，更新对照表，并完成数据迁移工作。</p>
<p>master bucket所在的dataserver负责迁移数据，根据这两张对照表，它可以判断出自己需要迁移的bucket，以及迁往何处。例如对于第一个bucket ：由 C 负责将数据迁移到 A。第二个bucket：由B 负责迁移到 A….</p>
<p>以第一个bucket为例：dataserver A 启动一个后台线程来完成bucket的迁移。迁移过程中，dataserver A需要继续对外提供读写服务。对于读操作而言，返回key对应的value就行，对于写操作而言，A 会检查key对应的bucket是否迁移完毕，如果已经迁移直接返回put/delete的返回码就行，如果没有迁移完毕</p>
<p>dataserver节点通过一个后台线程，来完成bucket的迁移任务。迁移数据的过程中，存储节点需要继续对外提供读写服务。对于读操作而言，节点根据请求的key, 到存储节点中读取数据并返回给应用。对写操作（ 包括write, delete等），存储节点会检查key对应的bucket是否已经迁移完毕（即该bucket迁移到了其他节点上了），若已迁移，则直接返回用户一个返回码（表示当前写操作没有成功，为什么？？）。当bucket正在迁移，并且没有结束的时候，写操作将数据写入存储引擎，并且将将日志写入磁盘。等待迁移完成之后，通过迁移日志，目的dataserver回放日志，从而保证了一致性。 当数据完成迁移之后，A 通知config server 第一个bucket已经迁移完成。</p>
<h1 id="Cache-热点问题"><a href="#Cache-热点问题" class="headerlink" title="Cache 热点问题"></a>Cache 热点问题</h1><p>某些高峰时段，会大量请求同一个Key（可能对应应用的某个促销商品、热点新闻、热点评论等），根据key的hash，所有读请求都将落到同一个server上，该机器的负载就会严重加剧。解决方法是：</p>
<ol>
<li>搭建一个备用集群，写的时候双写，然后随机双读。土办法，效率太低。</li>
<li>服务端做热点统计，同时通知客户端使用Local-cache逻辑：即在data-server上面运行热点统计逻辑，对每个到达的读请求，提取出key进行统计，并计算出当前请求中的热点key，同时当客户端访问的正好是热key，则向客户端回一个热点反馈feedback包。客户端收到feedback包之后，就将携带的hot-key写入客户端local-cache，同时拒绝非热key写入local-cache。</li>
</ol>
<p>具体热点key统计方法：<a href="http://www.atatech.org/articles/39329" target="_blank" rel="external">http://www.atatech.org/articles/39329</a></p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就去数据库中查找。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大压力。<br>解决方法：对查询结果为空的情况也进行缓存，缓存时间设置短一点。</p>
<h1 id="Tair分布式锁-原子操作"><a href="#Tair分布式锁-原子操作" class="headerlink" title="Tair分布式锁,原子操作"></a>Tair分布式锁,原子操作</h1><p>很多情况下，更新数据是先get(key)，修改get回来的value，然后put回dataserver。<br>如果有多个客户端get到同一份数据，都对其修改并保存，那么先保存的修改就会被后到达的修改覆盖，从而导致数据一致性问题。<br>Tair中存储的每个Key-Value都有版本号，版本号在每次更新后都会递增，相应的，在Tair put接口中也有此version参数，这个参数是为了解决并发更新同一个数据而设置的，类似于乐观锁。使用步骤如下：</p>
<ol>
<li>get(key)。如果get(key)返回success，则进入步骤2；如果key 对应的value不存在，则进入步骤3.</li>
<li>在调用put(key,value,version)的时候将步骤1 中get(key)返回的verison重新传入put(key,value,version)方法。dataserver根据version是否匹配，返回client是否put成功。</li>
<li>步骤1中get(key)对应的value不存在，则新put数据。<font color="red">此时传入的version一定不能不是0和1</font>（其他任何值都可以）。 因为传入0，tair会认为强制覆盖；而传入1，第一个client写入会成功后当前version=1，第二个client写入的时候发现当前写入的数据的version和当前version一样，造成数据的覆盖。</li>
</ol>
<p>下面是一个客户端多个线程并发计数的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TairCounter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String configId = <span class="string">"your configId"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> namespace = <span class="number">12345</span>;<span class="comment">//your namespace</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MultiClusterTairManager mcTairManager;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        mcTairManager = <span class="keyword">new</span> MultiClusterTairManager();</div><div class="line">        mcTairManager.setConfigID(configId);</div><div class="line">        mcTairManager.setDynamicConfig(<span class="keyword">true</span>);</div><div class="line">        mcTairManager.init();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</div><div class="line">        <span class="keyword">final</span> String key = <span class="string">"count"</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            executorService.submit(<span class="keyword">new</span> Counter(countDownLatch,key));</div><div class="line">        &#125;</div><div class="line">        countDownLatch.await();</div><div class="line">        <span class="comment">//始终输出100</span></div><div class="line">        System.out.println(mcTairManager.get(namespace, key).getValue().getValue());</div><div class="line">        mcTairManager.delete(namespace, key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch;</div><div class="line">        <span class="keyword">final</span> String key;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Counter</span><span class="params">(CountDownLatch countDownLatch, String key)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Result&lt;DataEntry&gt; result = mcTairManager.get(namespace, key);</div><div class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>)</div><div class="line">                System.out.println(<span class="string">"tair service error"</span>);</div><div class="line">            <span class="keyword">if</span> (ResultCode.DATANOTEXSITS.equals(result.getRc())) &#123;</div><div class="line">                <span class="comment">// value 不存在，更新为 1</span></div><div class="line">                ResultCode code = mcTairManager.put(namespace, key, <span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">                <span class="comment">//如果put成功</span></div><div class="line">                <span class="keyword">if</span> (code.isSuccess()) &#123;</div><div class="line">                    System.out.println(<span class="string">"get值为空，第一次put----成功"</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    System.out.println(<span class="string">"get值为空，put不成功,开始重试"</span>);</div><div class="line">                    <span class="comment">//重试</span></div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">                        result = mcTairManager.get(namespace, key);</div><div class="line">                        code = mcTairManager.put(namespace, key, (<span class="keyword">int</span>)result.getValue().getValue()+<span class="number">1</span>,result.getValue().getVersion(),<span class="number">100</span>);</div><div class="line">                        <span class="keyword">if</span> (code.isSuccess())</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                System.out.println(<span class="string">"get值不为空，put不成功，开始重试"</span>);</div><div class="line">                <span class="comment">//重试</span></div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">                    result = mcTairManager.get(namespace, key);</div><div class="line">                    ResultCode code = mcTairManager.put(namespace, key, (<span class="keyword">int</span>)result.getValue().getValue()+<span class="number">1</span>,result.getValue().getVersion(),<span class="number">100</span>);</div><div class="line">                    <span class="keyword">if</span> (code.isSuccess())</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            countDownLatch.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Tair文档：<a href="http://code.taobao.org/p/tair/wiki/index/" target="_blank" rel="external">http://code.taobao.org/p/tair/wiki/index/</a></p>
<p>Tair源码分析2：<a href="http://www.atatech.org/article/detail/6365/418" target="_blank" rel="external">http://www.atatech.org/article/detail/6365/418</a></p>
<p>Tair源码分析3：<a href="http://www.atatech.org/article/detail/9538/418" target="_blank" rel="external">http://www.atatech.org/article/detail/9538/418</a></p>
<p>Tair典型使用案例：<br><a href="http://www.atatech.org/articles/11131" target="_blank" rel="external">http://www.atatech.org/articles/11131</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;首先tair是一个的Key-Value结构分布式存储系统，既可以做高速缓存，也可以做持久化存储。分布式系统一般来说是一个集群，而在Tair的集群中主要存在如下几个模块：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConfigServer&lt;/strong&gt;&lt;br&gt;一个集群中包含2台configserver,两台configserver互为主备。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;维护和dataserver之间的心跳获得集群中存活可用的dataserver&lt;/li&gt;
&lt;li&gt;根据存活的dataserver 构建数据在集群中的分布信息（对照表）&lt;/li&gt;
&lt;li&gt;对client提供分部信息（对照表）的查询&lt;/li&gt;
&lt;li&gt;当dataserver挂掉，或者新添加dataserver的时候，调度各个dataserver完成数据的迁移，复制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;DataServer&lt;/strong&gt;&lt;br&gt;真正存放数据的地方&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供数据存储服务，接受client端的put/get/remove操作。&lt;/li&gt;
&lt;li&gt;执行数据迁移复制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;InvalidServer&lt;/strong&gt;&lt;br&gt;InvalidServer是一个可选模块，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收来自client的invalid/hide请求，对属于同一组的集群（双机房独立集群部署方式）做delete/hide操作，保证同一组集群的一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Client&lt;/strong&gt;&lt;br&gt;Tair提供出来的SDK&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在应用端提供访问Tair集群的接口。&lt;/li&gt;
&lt;li&gt;和ConfigServer通信，更新并缓存数据分布表和invalidserver地址等。&lt;/li&gt;
&lt;li&gt;LocalCache，避免过热数据访问影响tair集群服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在启动时，Client会根据本地的配置文件与ConfigServer通信。Client从Config Servcer处获得可用的DataServer地址，然后Client从这些DataServer获取真正的数据。&lt;br&gt;
    
    </summary>
    
      <category term="Tair" scheme="http://thinerzq.com/categories/Tair/"/>
    
    
      <category term="tair 分布式缓存" scheme="http://thinerzq.com/tags/tair-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>MetaQ(RocketMQ)学习</title>
    <link href="http://thinerzq.com/2016/07/25/metaQ%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/25/metaQ学习报告/</id>
    <published>2016-07-25T01:08:06.000Z</published>
    <updated>2016-08-14T14:37:32.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-消息中间件解决的问题"><a href="#1-消息中间件解决的问题" class="headerlink" title="1. 消息中间件解决的问题"></a>1. 消息中间件解决的问题</h1><p>消息中间件的核心作用就是三点：解耦，异步和并行，其中解耦是目的，异步和并行是表现形式。生产者和消费者彼此没有直接依赖，同步化解成了异步，大大减少了等待时间。例如：手机验证码的发送，当点击发送验证码的时候，只需要Client发送一条消息：{topic:sendVerifyCode,to:155xxxxxxxx,..}到消息中间件，消息中间件返回Client ok;然后消息中间件会将这条消息转发给订阅了这一个topic的Consumer，由Consumer去执行发送验证码的任务。由此看出消息中间主要做了三件事：接收消息+存储消息+转发消息。</p>
<h1 id="2-JMS-与-MetaQ"><a href="#2-JMS-与-MetaQ" class="headerlink" title="2. JMS 与 MetaQ"></a>2. JMS 与 MetaQ</h1><ol>
<li><p><strong>消息传递方式</strong><br>JMS：1 基于队列的点对点消费模型，2 基于发布/订阅的消费模型<br>MetaQ： 只有发布/订阅的消费方式</p>
</li>
<li><p><strong>消息类型</strong><br>JMS：TextMessage、MapMessage、BytesMessage，StreamMessage、ObjectMessage。<br>MetaQ：Message。</p>
</li>
<li><p><strong>消息持久性</strong><br>JMS：持久订阅，指示 JMS provider 持久保存消息，以保证消息不会因为 JMS provider 的失败而丢失。非持久订阅， 不要求 JMS provider 持久保存消息。<br>MetaQ 的消息都是持久性的</p>
</li>
<li><p>API<br>JMS：定义了消息中间件的生产端 api 和消费端 api，这些 api 都是约定的接口。<br>MetaQ：没有遵从JMS的定义，自己搞了一套。</p>
</li>
</ol>
<a id="more"></a>
<h1 id="3-MetaQ基本概念"><a href="#3-MetaQ基本概念" class="headerlink" title="3. MetaQ基本概念"></a>3. MetaQ基本概念</h1><p><strong><font color="blue">生产者</font></strong></p>
<blockquote>
<p>Producer:负责产生消息并发送消息到MetaQ服务器</p>
</blockquote>
<p><strong><font color="blue">消费者</font></strong></p>
<blockquote>
<p>Consumer:负责从MetaQ拉取消息并完成消费</p>
</blockquote>
<p><strong><font color="blue">Topic</font></strong></p>
<blockquote>
<p>消息的主题，由用户定义。类似于知乎的话题，Producer发送消息的时候需要指定发送到某一个topic下面，Consumer从某一个topic下面消费消息。</p>
</blockquote>
<p><strong><font color="blue">分区</font></strong></p>
<blockquote>
<p>同一个topic下面又分为多个分区，这些分区散落在各个服务器上，消息是发送到某一个topic下面的某一个分区，Consumer 也是从Topic下面的某一给分区拉取消息</p>
</blockquote>
<p><strong><font color="blue">Message</font></strong></p>
<blockquote>
<p>消息，负载发送的消息的信息。在生产者，服务端和 消费者之间传输</p>
</blockquote>
<p><strong><font color="blue">Broker</font></strong></p>
<blockquote>
<p>MetaQ的服务端。</p>
</blockquote>
<p><strong><font color="blue">Offset</font></strong></p>
<blockquote>
<p>消息在 Broker 上的每个分区都是组织成一个文件列表,消费者拉取数据需要知道数据在文件中的偏移量,这个偏移量就是所谓 offset。Offset 是绝对偏移量,服务器会将 offset 转化为具体文件的相对偏移量</p>
</blockquote>
<p><strong><font color="blue">Tag</font></strong></p>
<blockquote>
<p>每次发送一条消息的时候，给消息加一个Tag，方便Consumer过滤消息。</p>
</blockquote>
<p><strong><font color="blue">生产者Group/消费者Group</font></strong></p>
<blockquote>
<p>消费者可以是多个消费者共同消费一个 topic 下的消息,每个消费者消费部分消息。这些消费者就组成一个分组,拥有同一个分组名称,通常也称为消费者集群</p>
</blockquote>
<p><strong><font color="blue">集群消费/广播消费</font></strong></p>
<blockquote>
<ol>
<li>集群消费，一条消息只会被同一个group里一个消费者消费。    不同group之间相互不影响。</li>
<li>广播消费，一条消息会被同一个group里每一个消费端消费。</li>
</ol>
</blockquote>
<h1 id="4-消息写入，存储与读出"><a href="#4-消息写入，存储与读出" class="headerlink" title="4. 消息写入，存储与读出"></a>4. 消息写入，存储与读出</h1><p>MetaQ的存储结构是一种物理队列+逻辑队列的结构。如下图所示：<br>![metaq]/images/metaq.png)<br>Producer生产消息，根据消息的topic选择topic对应某一个分区，然后发送到这个分区对应的Broker；Consumer根据订阅的topic选择去topic的某一个分区拉取消息。</p>
<h2 id="4-1-生产者如何选择发送分区（生产者负载均衡）"><a href="#4-1-生产者如何选择发送分区（生产者负载均衡）" class="headerlink" title="4.1 生产者如何选择发送分区（生产者负载均衡）"></a>4.1 生产者如何选择发送分区（生产者负载均衡）</h2><p>每个broker都可以配置多个topic，每个topic可以有多少个分区。topic，broker,分区三者是多对多的关系。但是在生产者看来，一个topic在所有broker上的所有分区组成一个分区列表来使用。</p>
<p>在创建producer的时候，客户端会从zookeeper上获取publish的topic对应的broker和分区列表，生产者在发送消息的时候必须选择一台broker上的一个分区来发送消息。</p>
<p>生产者在通过zk获取分区列表之后，会按照brokerId和分区的顺序排列组织成一个有序的分区列表，<strong>发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息</strong>。考虑到我们的broker服务器软硬件配置基本一致，默认的轮询策略已然足够。</p>
<p>在broker因为重启或者故障等因素无法服务的时候，producer通过zookeeper会感知到这个变化，将失效的分区从列表中移除做到fail over。因为从故障到感知变化有一个延迟，可能在那一瞬间会有部分的消息发送失败(在这一瞬间如果发送的是顺序消息怎么办？)。</p>
<h2 id="4-2-存储消息"><a href="#4-2-存储消息" class="headerlink" title="4.2 存储消息"></a>4.2 存储消息</h2><p>MetaQ将消息存储在本地文件中，每个文件最大大小为1G，如果写入新的消息时，超过当前文件大小，则会自动新建一个文件。文件名称为起始字节大小。以起始字节大小命名并排序这些文件是有诸多好处的，当消费者要抓取某个起始偏移量开始位置的数据，会变的很简单，只要根据传上来的offset二分查找文件列表，定位到具体文件，然后将绝对offset减去文件的起始节点转化为相对offset，即可开始传输数据。假设，每个文件大小为1KB，图中Consumer1 订阅了TopicA,采用pull的方式来拉取消息，刚好Consumer1又被匹配到了TopicA_2分区，Consumer1需要获取{offset=1200,size=200}处的消息。需要经历如下的步骤：  </p>
<ol>
<li><p>当改pull请求发送到Broker1的时候，Broker1遍历TopicA_2分区（分区就是一些按照文件起始字节大小命名的索引文件，每一个索引文件又包含了多个索引项）找到offset对应的索引项{offset=1200,size=100B,tagHashcode=xxx}。</p>
</li>
<li><p>然后Broker1根据offset值二分查找TopicA_2的commitlog，获取到offset=1200的消息所在的真实文件（0000001024.meta）</p>
</li>
<li><p>根据真实文件的文件名000001024 获取offset=1300的消息所在文件的起始位置=276（1300-1024）</p>
</li>
<li><p>接下来，Broker1从TopicA_2分区的commitlog文件组中0000001024.meta文件的276B个字节开始，读取100B，然后返回给Consumer1。</p>
</li>
</ol>
<p>对于最终用户展现的消息队列只存储Offset,这样使得队列轻量化，单个队列数据量非常少。</p>
<p><strong>这样做的好处如下</strong>：<br>(1). 队列轻量化，单个队列数据量非常少。   </p>
<p>(2). 对磁盘的访问串行化，避免磁盘竟争，不会因为队列增加导致IOWAIT增高。   </p>
<p>每个方案都有<strong>缺点</strong>，它的缺点如下：   </p>
<p>(1). 写虽然完全是顺序写，但是读却变成了完全的随机读。   </p>
<p>(2). 读一条消息，会先读Consume Queue，再读Commit Log，增加了开销。  </p>
<p>(3). 要保证Commit Log与Consume Queue完全的一致，增加了编程的复杂度。  </p>
<p>以上缺点<strong>如何克服</strong>：<br>(1). 随机读，尽可能让读命中PAGECACHE，减少IO读操作，所以内存越大越好。如果系统中堆积的消息过多，读数据要访问磁盘会不会由于随机读导致系统性能急剧下降，答案是否定的。    </p>
<ol>
<li><p>访问PAGECACHE时，即使只访问1k的消息，系统也会提前预读出更多数据，在下次读时，就可能命中内存。</p>
</li>
<li><p>随机访问Commit Log磁盘数据，系统IO调度算法设置为NOOP(不是ANTICIPATORY吗)方式，会在一定程度上将完全的随机读变成顺序跳跃方式</p>
</li>
</ol>
<p>(2). 由于Consume Queue存储数据量极少，而且是顺序读，在PAGECACHE预读作用下，Consume Queue的读性能几乎与内存一致，即使堆积情况下。所以可认为Consume Queue完全不会阻碍读性能。</p>
<p>(3). Commit Log中存储了所有的元信息，包含消息体，类似于Mysql、Oracle的redolog，所以只要有Commit Log在，Consume Queue即使数据丢失，仍然可以恢复出来。</p>
<p>在读取消息的时候，如何加快读取消息的速度？<br>传统的read调用会经历内核态–&gt;用户态—&gt;内核态—&gt;网卡缓冲区这样一个复杂的过程。MetaQ使用了mmap的方式，将硬盘文件映射到用内存中，也就是将page cache中的页直接映射到用户进程地址空间中，从而进程可以直接访问自身地址空间的虚拟地址来访问page cache中的页，这样会并不会涉及page cache到用户缓冲区之间的拷贝。对于小文件比较管用</p>
<h2 id="4-3-消费者如何选择拉取的分区（消费者负载均衡）"><a href="#4-3-消费者如何选择拉取的分区（消费者负载均衡）" class="headerlink" title="4.3 消费者如何选择拉取的分区（消费者负载均衡）"></a>4.3 消费者如何选择拉取的分区（消费者负载均衡）</h2><p>消费者的负载均衡跟topic的分区数目紧密相关，要考察几个场景。</p>
<p>首先，单个分组内的消费者数目如果比总的分区数目多的话，则多出来的消费者不参与消费。</p>
<p>其次，如果分组内的消费者数目比分区数目小，则有部分消费者要额外承担消息的消费任务。</p>
<p>Meta的客户端会自动帮处理消费者的负载均衡，它会将消费者列表和分区列表分别排序，然后按照上述规则做合理的挂载。合理地设置分区数目至关重要。如果分区数目太小，则有部分消费者可能闲置，如果分区数目太大，则对服务器的性能有影响。<br>在某个消费者故障或者重启等情况下，其他消费者会感知到这一变化（通过 zookeeper watch消费者列表），然后重新进行负载均衡，保证所有的分区都有消费者进行消费。</p>
<h1 id="5-如何保证消息不丢"><a href="#5-如何保证消息不丢" class="headerlink" title="5. 如何保证消息不丢"></a>5. 如何保证消息不丢</h1><h2 id="5-1-生产者可靠性保证"><a href="#5-1-生产者可靠性保证" class="headerlink" title="5.1 生产者可靠性保证"></a>5.1 生产者可靠性保证</h2><p>消息生产者发送消息后返回SendResult，如果isSuccess返回为true,则表示消息已经确认发送到服务器并被服务器接收存储。整个发送过程是一个同步的过程。保证消息送达服务器并返回结果。</p>
<h2 id="5-2-服务器可靠性保证"><a href="#5-2-服务器可靠性保证" class="headerlink" title="5.2 服务器可靠性保证"></a>5.2 服务器可靠性保证</h2><p>消息生产者发送的消息，meta服务器收到后在做必要的校验和检查之后的第一件事就是写入磁盘，写入成功之后返回应答给生产者。因此，可以确认每条发送结果为成功的消息服务器都是写入磁盘的。写入磁盘，不意味着数据落到磁盘设备上，毕竟我们还隔着一层os，os对写有缓冲。Meta有以下刷盘策略：</p>
<p><strong>异步刷盘</strong>：  </p>
<ol>
<li>每1000条消息（可配置），即强制调用一次force来写入磁盘设备。</li>
<li>每隔10秒（可配置），强制调用一次force来写入磁盘设备。    </li>
</ol>
<p><strong>同步刷盘</strong><br>如果存储配置上的groupCommitEnable选项为true，则会在写入消息后，立即强制刷盘。</p>
<h2 id="5-3-消费者可靠性保证"><a href="#5-3-消费者可靠性保证" class="headerlink" title="5.3 消费者可靠性保证"></a>5.3 消费者可靠性保证</h2><p>消费者是一条接着一条地消费消息，只有在成功消费一条消息后才会接着消费下一条。如果在消费某条消息失败（如异常），则会尝试重试消费这条消 息（默认最大5次），超过最大次数后仍然无法消费，则将消息存储在消费者的本地磁盘，由后台线程继续做重试。而主线程继续往后走，消费后续的消息。因此， 只有在MessageListener确认成功消费一条消息后，meta的消费者才会继续消费另一条消息。由此来保证消息的可靠消费。消费者的另一个可靠性的关键点是offset的存储，也就是拉取数据的偏移量。默认存储在zoopkeeper上，zookeeper通过集群来保证数据的安全性。Offset会定期保存，并且在每次重新负载均衡前都会强制保存一次，因此可能会存在极端情况下的消息的重复消费。</p>
<h1 id="6-消息过滤（服务端-客户端）"><a href="#6-消息过滤（服务端-客户端）" class="headerlink" title="6. 消息过滤（服务端/客户端）"></a>6. 消息过滤（服务端/客户端）</h1><p>消息过滤主要使用Message 的Tag字段做的。</p>
<ol>
<li>在服务端，每一条消息对应的Tag被转换成一个8byte的hashcode, 在Broker 端对比Queue中每一个存储单元的的hashcode和 订阅的Tag的hashcode进行对比，不符合，则跳过，继续比对下一个，符合则传输给Consumer。在队列中进行hashcode对比</li>
<li>Consumer 收到过滤后的消息后，再次将传递过来的Message中的Tag字符串和订阅的Tag字符串进行对比，不是hashcode。这样做可以避免Hash冲突</li>
</ol>
<h1 id="7-消息重复性"><a href="#7-消息重复性" class="headerlink" title="7. 消息重复性"></a>7. 消息重复性</h1><p>MetaQ<font color="red">不能保证消息不重复</font>,原因如下：</p>
<ul>
<li>发送消息阶段，会存在分布式环境下典型的超时问题,即发送阶段不能保证消息不重复。</li>
<li>订阅消息阶段，由于涉及集群订阅，多个订阅方需要使用负载均衡方式订阅，在因负载均衡出现的短暂不一致的情况下可能会重复。</li>
<li>订阅者意外宕机，消费进度未及时存储也会产生息重复。</li>
</ul>
<p>如何解决？</p>
<ul>
<li>Consumer收到消息后，通过Tair,DB去重。</li>
<li>使用Pull的方式拉取消息，但是Pull的时候，怎么协调分配队列需要应用控制。</li>
</ul>
<h1 id="8-消息顺序性"><a href="#8-消息顺序性" class="headerlink" title="8. 消息顺序性"></a>8. 消息顺序性</h1><p><strong>顺序消息</strong>：消费消息的顺序要同发送消息的顺序一致，在 MetaQ 中，主要指的是局部顺序，即一类消息为满足顺 序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送 的顺序去消费消息。</p>
<p><strong>普通顺序消息</strong>：顺序消息的一种，正常情况下可以保证完全的顺序消息，但是一旦发生通信异常，Broker 重启，由于队列 总数发生变化，哈希取模后定位的队列会变化，产生短暂的消息顺序不一致。 如果业务能容忍在集群异常情况（如某个 Broker 宕机或者重启）下，消息短暂的乱序，使用普通顺序方 式比较合适。</p>
<p><strong>严格顺序消息</strong>：顺序消息的一种，无论正常异常情况都能保证顺序，但是牺牲了分布式 Failover 特性，即 Broker 集群中只 要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。 如果服务器部署为同步双写模式，此缺陷可通过备机自动切换为主避免，不过仍然会存在几分钟的服务不可用。</p>
<h1 id="9-Pull-Push模型对比"><a href="#9-Pull-Push模型对比" class="headerlink" title="9. Pull/Push模型对比"></a>9. Pull/Push模型对比</h1><p>Pull: Comsumer主动请求Broker获取消息，请求的时候需要指定消息的offset（第一次读取为0，根据每次读取的返回值可以获取到下一次需要读取的offset）。这样只要事先知道offset，只要消息还没有被清除就能读取消息出来在（即使已经读取过了）</p>
<p>Push：Consumer事先注册监听，由Broker主动推送消息到Consumer。Push能加载出未读取的消息的原因是MetaQ的服务端维护了一个offset。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-消息中间件解决的问题&quot;&gt;&lt;a href=&quot;#1-消息中间件解决的问题&quot; class=&quot;headerlink&quot; title=&quot;1. 消息中间件解决的问题&quot;&gt;&lt;/a&gt;1. 消息中间件解决的问题&lt;/h1&gt;&lt;p&gt;消息中间件的核心作用就是三点：解耦，异步和并行，其中解耦是目的，异步和并行是表现形式。生产者和消费者彼此没有直接依赖，同步化解成了异步，大大减少了等待时间。例如：手机验证码的发送，当点击发送验证码的时候，只需要Client发送一条消息：{topic:sendVerifyCode,to:155xxxxxxxx,..}到消息中间件，消息中间件返回Client ok;然后消息中间件会将这条消息转发给订阅了这一个topic的Consumer，由Consumer去执行发送验证码的任务。由此看出消息中间主要做了三件事：接收消息+存储消息+转发消息。&lt;/p&gt;
&lt;h1 id=&quot;2-JMS-与-MetaQ&quot;&gt;&lt;a href=&quot;#2-JMS-与-MetaQ&quot; class=&quot;headerlink&quot; title=&quot;2. JMS 与 MetaQ&quot;&gt;&lt;/a&gt;2. JMS 与 MetaQ&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;消息传递方式&lt;/strong&gt;&lt;br&gt;JMS：1 基于队列的点对点消费模型，2 基于发布/订阅的消费模型&lt;br&gt;MetaQ： 只有发布/订阅的消费方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;消息类型&lt;/strong&gt;&lt;br&gt;JMS：TextMessage、MapMessage、BytesMessage，StreamMessage、ObjectMessage。&lt;br&gt;MetaQ：Message。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;消息持久性&lt;/strong&gt;&lt;br&gt;JMS：持久订阅，指示 JMS provider 持久保存消息，以保证消息不会因为 JMS provider 的失败而丢失。非持久订阅， 不要求 JMS provider 持久保存消息。&lt;br&gt;MetaQ 的消息都是持久性的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;API&lt;br&gt;JMS：定义了消息中间件的生产端 api 和消费端 api，这些 api 都是约定的接口。&lt;br&gt;MetaQ：没有遵从JMS的定义，自己搞了一套。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="MetaQ" scheme="http://thinerzq.com/categories/MetaQ/"/>
    
    
      <category term="MetaQ RocketMQ 消息队列" scheme="http://thinerzq.com/tags/MetaQ-RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>HSF学习</title>
    <link href="http://thinerzq.com/2016/07/22/HSF%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/22/HSF学习报告/</id>
    <published>2016-07-22T01:08:06.000Z</published>
    <updated>2016-08-14T14:36:49.730Z</updated>
    
    <content type="html"><![CDATA[<p>HSF(High-Speed Service Framework)，是一个高性能的分布式服务框架。一个分布式框架提供的最基本的功能就是远程调用（A机器调用B机器上的一个对象的方法，B机器将方法到返回值发送回A机器）。HSF面向接口编程，以“Service”的形式进行远程调用，简单的说就是接口的具体实现(服务)运行在服务器上，服务器将这些接口暴露出来，客户端拿到这些接口之后通过接口调用具体的服务。在服务发布和调用过程中主要涉及到下面这些知识。</p>
<h1 id="1-服务注册"><a href="#1-服务注册" class="headerlink" title="1.服务注册"></a>1.服务注册</h1><p>服务注册的基本要素就是</p>
<h2 id="1-1-将服务metadata发布到ConfigServer上"><a href="#1-1-将服务metadata发布到ConfigServer上" class="headerlink" title="1.1 将服务metadata发布到ConfigServer上"></a>1.1 将服务metadata发布到ConfigServer上</h2><p>ConfigServer就是存放ServiceID – ip地址映射关系(多对多)的机器，服务的元信息包括在HSFSpringProviderBean中配置的信息和服务所在的ip地址。服务的发布流程非常复杂</p>
<p>首先在beans里面配置一个HSFSpringProviderBean以及一些属性，必要的有serviceInterface和target。在HSFSpringProviderBean里面还包装了一层 HSFApiProviderBean,HSFApiProviderBean里面包装了ServiceMetadata元数据类（关于服务的配置信息基本都在这儿）和MetadataService类，当所有配置的属性初始化完成之后，就开始调用init方法做一些发布之前的配置信息检查，再调用publish方法准备发布服务（这里面涉及到一个HSFServiceContainer单例类），通过HSFServiceContainer得到ProcessComponent的对象，调用ProcessComponent.publish()方法正真的发布服务.实际的发布过程挺复杂。</p>
<h2 id="1-2-将服务对象注册到本地Server容器，"><a href="#1-2-将服务对象注册到本地Server容器，" class="headerlink" title="1.2. 将服务对象注册到本地Server容器，"></a>1.2. 将服务对象注册到本地Server容器，</h2><p>将某一个接口的具体实现注册到本地的Server容器里面，等待客户端调用</p>
<a id="more"></a>
<h1 id="2-服务发现"><a href="#2-服务发现" class="headerlink" title="2. 服务发现"></a>2. 服务发现</h1><p>为了调用一个HFS服务，客户端首先要从ConfigServer订阅这个服务的dataId，及时拿到服务发布方的地址列表。。ConfigServer负责管理地址，异步推送。服务提供者将服务发布到某一个机器上，并向ConfigServer报告服务所在的机器ip和服务对应的ddataId。当服务消费者需要调用服务的时候，首先向ConfigServer请求服务对应的ip,根据配置的规则（服务寻址）返回某一个ip，之后由服务消费者向对应的服务提供者ip发起TCP连接，建立通信。整个服务发现的过程就完成了</p>
<h1 id="3-远程调用"><a href="#3-远程调用" class="headerlink" title="3. 远程调用"></a>3. 远程调用</h1><p>分布式框架主要特点就是远程调用，在提供强大的远程调用能力时不损失本地调用的语义简洁性.  由于HSF自身屏蔽了异步网络之间调用的差异性，同时HSF采用面向接口的实现形式，整个远程调用的关键就是拿到和服务端暴露出来的借口并编写正确清晰的业务逻辑。<br>调用分类</p>
<ol>
<li>Sync,这个就是一般同步调用，不适合于耗时长的服务调用。</li>
<li>Future，这个和Java中的Future模式一样，在需要的时候通过HSFResponseFuture.getResponse(timeout)返回结果</li>
<li>Callback，这个是属于回调类型，需要注意的是由于只用方法名字来标识方法,所以并不区分重载的方法。同名的方法都会被设置为同样的调用方式。<br>回调函数是由 io 线程来调用, 所以不要在拿到结果后做费时的操作。<br>不能在 onReponse 里边再发起 hsf 调用,目前这种做法可能导致 io 线程挂起,无法恢复。</li>
<li>泛化调用，就是完全剥离的对api的依赖，以字符串的形式提供远程调用的接口名，方法名，参数类型等</li>
</ol>
<h1 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4. 动态代理"></a>4. 动态代理</h1><p>动态代理主要用于实现无侵入式的代码扩展和远程调用，动态代理在远程调用中主要是通过在InvocationHandler的invoke方法里面将需要调用的对象的名字，方法的名字，参数等信息发送给服务端，等待服务端的返回。因为HSF使用的是基于接口的编程，所以其中的代理主要使用的是jdk自带的动态代理。</p>
<h1 id="5-序列化-反序列化"><a href="#5-序列化-反序列化" class="headerlink" title="5. 序列化/反序列化"></a>5. 序列化/反序列化</h1><p>序列化一般用于本地持久化存储和网络传输，在这里使用序列化主要就是将客户端和服务端需要传递到对端的对象转化成字节数组，以便于网络传输。序列化的产品比较多，HSF的序列化是通过Hessian来完成的。下面将Java自带的序列化和Hessian做一个对比：</p>
<ol>
<li>Java序列化会把要序列化的对象类的元数据和业务数据全部序列化从字节流，而且是把整个继承关系上的东西全部序列化了。它序列化出来的字节流是对那个对象结构到内容的完全描述，包含所有的信息，因此效率较低而且字节流比较大。但是由于确实是序列化了所有内容，所以可以说什么都可以传输，因此也更可用和可靠。   </li>
<li>hessian序列化，它的实现机制是着重于数据，附带简单的类型信息的方法。就像Integer a = 1，hessian会序列化成I 1这样的流，I表示int or Integer，1就是数据内容。而对于复杂对象，通过Java的反射机制，hessian把对象所有的属性当成一个Map来序列化，产生类似M className1 propertyName1 I 1 propertyName S stringValue这样的流，包含了基本的类型描述和数据内容。而在序列化过程中，如果一个对象之前出现过，hessian会直接插入一个R index这样的块来表示一个引用位置，从而省去再次序列化和反序列化的时间。Hessian序列化直接忽略了serialVersionUID，同时在遇到子类和父类中有同名变量的时候，对子类进行序列化子类的值被父类的值覆盖的问题。</li>
</ol>
<h1 id="6-超时机制"><a href="#6-超时机制" class="headerlink" title="6. 超时机制"></a>6. 超时机制</h1><p>超时机制是远程方法调用过程中配置调用超时的超时时间，可以在服务端和客户端同时配置，同时配置可以细化到接口和接口中的方法。clientTimeout：对接口中的所有方法生效，methodspecial,对指定的某几个方法生效。四个方法的优先级规则如下：    客户端methodspecial &gt; 客户端clientTimeout &gt; 服务端methodspecial &gt; 服务端clientTimeout。超时了HSF会throw HSFTimeoutException，由业务代码catch之后处理，比如重试、fail fast等等。</p>
<h1 id="7-机房路由"><a href="#7-机房路由" class="headerlink" title="7. 机房路由"></a>7. 机房路由</h1><p>机房路由主要指的是分布在所有服务器上的各个服务的调用规则，主要通过Diamond配置中心配置的</p>
<ol>
<li>路由规则，可以通过groovy脚本指定接口路由，方法路由，参数路由。</li>
<li>归组规则，用于对发布了同一 HSF 服务的所有机器进行统一归组的规则 。通过xml文件配置</li>
<li>同机房优先规则，保证 HSF 服务消费者在请求 HSF 服务时，优先选择与服务消费者同机房的服务提供者。主要需要指定一个阈值，生效阀值的计算方法: 服务可用比例=本机房可用机器数量/所有服务机器数量 当服务可用比例 &gt;= threshold 时，启用本地机房优先策略，当服务可用比例 &lt; threshold 时，本地机房优先策略关闭,服务仍然采用随机调用的方式。通过xml形式配置</li>
<li>权重规则，如果用户不想对流量进行硬性导向，但倾向于将流量多往某几台机 器上引导，这时候就可以将这几台机器的权重规则配置大一点。某一台机器的调用概率计算公式：某一台机器的权重/所有机器的权重之和。</li>
<li>全局规则，配置HSF日志级别，虚机房等</li>
<li>TPS限流，允许应用提供方指定某个接口的TPS，当单位时间内的TPS达到设定值时，该接口将停止对外提供服务，所有的请求都会被拦截（立刻返回，错误消息TPS限流)，直到下一个刷新时间点。支持接口级别和方法级别。</li>
<li>支持应用级别，接口级别和方法级别，只有白名单中的应用才可以调用，通过Diamond推送到服务端生效。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HSF作为一个高性能分布式服务框架，主要使用了ConfigServer来作为注册中心，Diamond来做软负载，通过接口变成实现动态代理。它的高性能应该主要体现在Diamond中规则的配置和ConfigServer的服务的动态注册和发现。从HSF的整体结构上来看,还涉及到了协议层，以及Netty网络流传输。<br><img src="/images/hsf.png" alt="HSF整体结构"><br>下面这几点配合链接里面流程图和源码看对于深入理解HSF很有启发，</p>
<ol>
<li><a href="http://www.atatech.org/articles/43956" target="_blank" rel="external">HSF服务发布流程</a></li>
<li><a href="http://www.atatech.org/articles/43956" target="_blank" rel="external">HSF服务消费流程</a></li>
<li><a href="http://www.atatech.org/articles/51156" target="_blank" rel="external">服务端发布与处理请求，客户端订阅与调用流程</a></li>
<li><a href="http://iwinit.iteye.com/blog/1745132" target="_blank" rel="external">容器启动流程</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HSF(High-Speed Service Framework)，是一个高性能的分布式服务框架。一个分布式框架提供的最基本的功能就是远程调用（A机器调用B机器上的一个对象的方法，B机器将方法到返回值发送回A机器）。HSF面向接口编程，以“Service”的形式进行远程调用，简单的说就是接口的具体实现(服务)运行在服务器上，服务器将这些接口暴露出来，客户端拿到这些接口之后通过接口调用具体的服务。在服务发布和调用过程中主要涉及到下面这些知识。&lt;/p&gt;
&lt;h1 id=&quot;1-服务注册&quot;&gt;&lt;a href=&quot;#1-服务注册&quot; class=&quot;headerlink&quot; title=&quot;1.服务注册&quot;&gt;&lt;/a&gt;1.服务注册&lt;/h1&gt;&lt;p&gt;服务注册的基本要素就是&lt;/p&gt;
&lt;h2 id=&quot;1-1-将服务metadata发布到ConfigServer上&quot;&gt;&lt;a href=&quot;#1-1-将服务metadata发布到ConfigServer上&quot; class=&quot;headerlink&quot; title=&quot;1.1 将服务metadata发布到ConfigServer上&quot;&gt;&lt;/a&gt;1.1 将服务metadata发布到ConfigServer上&lt;/h2&gt;&lt;p&gt;ConfigServer就是存放ServiceID – ip地址映射关系(多对多)的机器，服务的元信息包括在HSFSpringProviderBean中配置的信息和服务所在的ip地址。服务的发布流程非常复杂&lt;/p&gt;
&lt;p&gt;首先在beans里面配置一个HSFSpringProviderBean以及一些属性，必要的有serviceInterface和target。在HSFSpringProviderBean里面还包装了一层 HSFApiProviderBean,HSFApiProviderBean里面包装了ServiceMetadata元数据类（关于服务的配置信息基本都在这儿）和MetadataService类，当所有配置的属性初始化完成之后，就开始调用init方法做一些发布之前的配置信息检查，再调用publish方法准备发布服务（这里面涉及到一个HSFServiceContainer单例类），通过HSFServiceContainer得到ProcessComponent的对象，调用ProcessComponent.publish()方法正真的发布服务.实际的发布过程挺复杂。&lt;/p&gt;
&lt;h2 id=&quot;1-2-将服务对象注册到本地Server容器，&quot;&gt;&lt;a href=&quot;#1-2-将服务对象注册到本地Server容器，&quot; class=&quot;headerlink&quot; title=&quot;1.2. 将服务对象注册到本地Server容器，&quot;&gt;&lt;/a&gt;1.2. 将服务对象注册到本地Server容器，&lt;/h2&gt;&lt;p&gt;将某一个接口的具体实现注册到本地的Server容器里面，等待客户端调用&lt;/p&gt;
    
    </summary>
    
      <category term="HSF" scheme="http://thinerzq.com/categories/HSF/"/>
    
    
      <category term="HSF 分布式服务" scheme="http://thinerzq.com/tags/HSF-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Ibatis学习</title>
    <link href="http://thinerzq.com/2016/07/20/ibatis%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/20/ibatis学习报告/</id>
    <published>2016-07-20T01:08:06.000Z</published>
    <updated>2016-08-14T14:31:13.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iBatis-简介："><a href="#iBatis-简介：" class="headerlink" title="iBatis 简介："></a>iBatis 简介：</h1><p>iBatis 是apache 的一个开源项目(2010后改名为Mybatis)，一个半自动化的O/R Mapping 解决方案，iBatis 最大的特点就是小巧，上手很快。<br>适用于以下场景：</p>
<ol>
<li>系统的部分或全部数据来自现有数据库，出于安全考虑，只对开发团队提供几条Select SQL（或存储过程）以获取所需数据，具体的表结构不予公开。</li>
<li>开发规范中要求，所有牵涉到业务逻辑部分的数据库操作，必须在数据库层由存储过程实现</li>
<li>系统数据处理量巨大，性能要求极为苛刻，这往往意味着必须通过经过高度优化的SQL语句才能达到系统性能设计指标。</li>
</ol>
<p>ORM框架都是在JDBC层面上的封装，把如下的jdbc代码分解到不同的步骤去执行，以达到流程化，可定制，方便配置管理的目的。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">Connection conn= DriverManager.getConnection(url,user,password);</div><div class="line">PreparedStatement  st = conn.prepareStatement(sql);</div><div class="line">st.setInt(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">st.execute();</div><div class="line">ResultSet rs =  st.getResultSet();</div><div class="line"><span class="keyword">while</span>(rs.next())&#123;</div><div class="line">    String result = rs.getString(colname);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>iBatis主要做了两件事:</p>
<ul>
<li>根据 JDBC 规范建立与数据库的连接</li>
<li>通过反射打通 Java 对象与数据库参数交互之间相互转化关系。</li>
</ul>
<p>iBATIS的一个重要组成部分就是其 SqlMap 配置文件，SqlMap 配置文件的核心是 Statement 语句包括CRUD。 iBATIS 通过解析 SqlMap 配置文件得到所有的 sql 执行语句，同时会形成 ParameterMap、ResultMap 两个对象用于处理sql语句中的参数和sql语句执行后的ResultSet–&gt;Object的构造。</p>
<a id="more"></a>
<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><h2 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h2><ul>
<li><p>properties：将数据连接单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值，在SqlMapConfig.xml中就不需要对数据库连接参数进行硬编码。数据库连接参数只配置在db.properties中，方便对参数进行统一管理，其它xml可以引用该db.properties</p>
</li>
<li><p>settings：全局配置参数，用于配置和优化SqlMapClient实例的各选项，如缓存，延迟加载，最大线程数等等。</p>
</li>
<li>typeAlias：为一个通常较长的、全限定类名指定一个较短的别名。SQL Map配置文件预定义了几个别名<ol>
<li>JDBC com.ibatis.sqlmap.engine.transaction.jdbc.JdbcTransactionConfig</li>
<li>JTA    com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</li>
<li>EXTERNAL com.ibatis.sqlmap.engine.transaction.external.ExternalTransactionConfig</li>
<li>SIMPLE   com.ibatis.sqlmap.engine.datasource.SimpleDataSourceFactory</li>
<li>DBCP     com.ibatis.sqlmap.engine.datasource.DbcpDataSourceFactory</li>
<li>JNDI     com.ibatis.sqlmap.engine.datasource.JndiDataSourceFactory</li>
</ol>
</li>
<li><p>transactionManager ： 为SQL Map配置事务管理服务。属性type指定所使用的事务管理器类型。这个属性值可以是一个类名，也可以是一个别名。包含在框架的三个事务管理器分别是：JDBC，JTA和EXTERNAL。</p>
<ul>
<li>JDBC：通过常用的Connection commit()和rollback()方法，让JDBC管理事务。</li>
<li>JTA：本事务管理器使用一个JTA全局事务，使SQL Map的事务包括在更大的事务范围内，这个更大的事务范围可能包括了其他的数据库和事务资源。这个配置需要一个UserTransaction属性，以便 从JNDI获得一个UserTransaction</li>
<li>EXTERNAL：这个配置可以让您自己管理事务。您仍然可以配置一个数据源，但事务不再作为框架生命周期的一部分被提交或回退。这意味着SQL Map外部应用的一部分必须自己管理事务。这个配置也可以用于没有事务管理的数据库（例如只读数据库）</li>
</ul>
</li>
<li><p>dataSource：是transactionManager的一部分，为SQL Map数据源设置了一系列参数。必需配置的是的是jdbcdriver url,username,password。</p>
</li>
<li>sqlMap ：用于包括SQL Map映射文件和其他的SQL Map配置文件。每个SqlMapClient对象使用的所有SQL Map映射文件都要在此声明。映射文件作为stream resource从类路径或URL读入。</li>
</ul>
<h2 id="sqlMap-xml"><a href="#sqlMap-xml" class="headerlink" title="sqlMap.xml"></a>sqlMap.xml</h2><p>sqlMap.xml常用的配置文件的通常主要包括一些具体的sql操作映射,具体说来主要包括如下的元素：</p>
<ul>
<li>sqlMap: sqlMap作为根节点，其中的namespace属性用来防止不同的sqlMap文件中同名方法的冲突，在调用的时候使用namespace.id调用就行了。</li>
<li>typeAlias</li>
<li>resultMap：结果映射，主要用于指定数据库列名和返回对象属性名的对应关系</li>
<li>parameterMap：参数映射，主要用于指定传入参数对象的属性名以及类型与数据库列名与类型的对应关系。</li>
<li>insert，select,update,delete：用于写CRUD 语句的标签，它的parameterMap和resultMap属性指定了程序传递进来的参数如何映射构成sql语句，已经如果将ResultSet结果返回成需要的对象。select中有一个selectKey用于自动生成数据库主键；select语句中可以使用cacheModel来指定缓存。</li>
<li>procedure:用于定义存储过程</li>
<li>sql：定义一段公用的sql语句，在insert,select，update,delete中引用，消除重复<h3 id="映射关系分析"><a href="#映射关系分析" class="headerlink" title="映射关系分析"></a>映射关系分析</h3>ibateis中，parameterClass的类型大都是：String,Integer/Object/Hashmap<br>resultclass/resultMap的类型大都是：Object/Hashmap</li>
</ul>
<ol>
<li>当parameterClass为string,int时，可用#value#表示或直接用传入的值名表示。</li>
<li>当parameterClass/resultMap的类型是对象时，用#属性#表示。程序会调用JAVABEAN的getter方法，进行获取属性值。</li>
<li>当parameterClass/resultMap的类型是hashmap时，那程序会直接通过key来分析取参数。</li>
<li>#是把传入的数据当作字符串，#方式一般用于传入插入/更新的值或查询/删除的where条件。通过PreparedStatement.set(1,value)的形式插入到sql中</li>
<li>$传入的数据直接生成在sql里。$方式一般用于传入数据库对象．例如传入表名.</li>
</ol>
<h3 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h3><p>ibatis还要一个功能点就是动态映射，提高了SQL语句的重用性和灵活性。主要做法就是提供了一系列的动态SQL标签，能够根据传入的参数值的数量，大小，null等做判断生成对应的sql。主要的标签有dynamic,isNull,isNotNull,iterator等。</p>
<h1 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h1><p>一切都要从SqlMapClientBuilder开始说起。首先构造InputStream或者Reader读取配置文件，然后通过SqlMapClientBuilder的静态方法实例化SqlMapConfigParser，其中使用org.w3c.dom来解析文档，当读到xx标签的时候，就实例化xx标签对应的对象）。等到文件解析完,数据源，事物等配置好，所有的CRUD语句加载完返回SqlMapClient实例，SqlMapClient提供了程序和ibatis的交互接口</p>
<h1 id="重要类的说明"><a href="#重要类的说明" class="headerlink" title="重要类的说明"></a>重要类的说明</h1><ul>
<li>SqlMapClient：提供给编程者的接口，使用这个接口可以执行SqlMap文件中定义的半形式化的sql语句</li>
<li>SqlMapClientImpl：SqlMapClientImpl类使用了ThreadLocal类型的成员变量来存储关联的SqlMapSessionImpl对象。这就是限制了每个线程都只能操作自己记录的SqlMapSessionImpl数据，从而保证了该属性的线程安全。</li>
<li>SqlMapSessionImpl：主要是为了持有本次session的SessionScope对象，这个勒种的绝大部分数据操作都转交给了SqlMapExecutorDelegate去完成。</li>
<li>SqlMapExecutorDelegate：一个工具类，所有的SqlMapClient提供给外部的操作都是通过这个类来完成的，主要为各个操作开启，关闭事物的。</li>
<li>MappedStatement：为各个CRUD方法的构造RowHandlerCallback对象，验证参数类型，取出参数。</li>
<li>SqlMapExecutor：实例化PreparedStatement, 取得TypeHandler，获取ParameterMap为PreparedStatement设置参数，并执行最终的sql语句得到ResultSet,并调用 MappedStatement中的RowHandlerCallback处理返回结果，RowHandlerCallback获取到当前的ResultMap判断是哪一种DataExchange(object,hashmap,list)并使用对应的DataExchange做类型映射，最后通过ResultObjectFactoryUtil通过反射实例化需要返回的对象。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>iBatis真的是一个简单易学的持久层框架，将Sql语言与java程序分离，便于维护和开发，大大简化了jdbc操作。与Hibernate相比，虽然没有Hibernate的功能强大，sql语言的效率更高，更灵活。Hibernate提供了从object&lt;–&gt;jdbc完全的封装，用多了sql语句会生疏，iBatis更加的简单易懂，配置灵活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iBatis-简介：&quot;&gt;&lt;a href=&quot;#iBatis-简介：&quot; class=&quot;headerlink&quot; title=&quot;iBatis 简介：&quot;&gt;&lt;/a&gt;iBatis 简介：&lt;/h1&gt;&lt;p&gt;iBatis 是apache 的一个开源项目(2010后改名为Mybatis)，一个半自动化的O/R Mapping 解决方案，iBatis 最大的特点就是小巧，上手很快。&lt;br&gt;适用于以下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统的部分或全部数据来自现有数据库，出于安全考虑，只对开发团队提供几条Select SQL（或存储过程）以获取所需数据，具体的表结构不予公开。&lt;/li&gt;
&lt;li&gt;开发规范中要求，所有牵涉到业务逻辑部分的数据库操作，必须在数据库层由存储过程实现&lt;/li&gt;
&lt;li&gt;系统数据处理量巨大，性能要求极为苛刻，这往往意味着必须通过经过高度优化的SQL语句才能达到系统性能设计指标。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ORM框架都是在JDBC层面上的封装，把如下的jdbc代码分解到不同的步骤去执行，以达到流程化，可定制，方便配置管理的目的。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Class.forName(&lt;span class=&quot;string&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Connection conn= DriverManager.getConnection(url,user,password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PreparedStatement  st = conn.prepareStatement(sql);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;st.setInt(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;st.execute();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ResultSet rs =  st.getResultSet();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(rs.next())&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    String result = rs.getString(colname);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;iBatis主要做了两件事:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 JDBC 规范建立与数据库的连接&lt;/li&gt;
&lt;li&gt;通过反射打通 Java 对象与数据库参数交互之间相互转化关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;iBATIS的一个重要组成部分就是其 SqlMap 配置文件，SqlMap 配置文件的核心是 Statement 语句包括CRUD。 iBATIS 通过解析 SqlMap 配置文件得到所有的 sql 执行语句，同时会形成 ParameterMap、ResultMap 两个对象用于处理sql语句中的参数和sql语句执行后的ResultSet–&amp;gt;Object的构造。&lt;/p&gt;
    
    </summary>
    
      <category term="ibatis" scheme="http://thinerzq.com/categories/ibatis/"/>
    
    
      <category term="ibatis" scheme="http://thinerzq.com/tags/ibatis/"/>
    
  </entry>
  
  <entry>
    <title>Jvm学习</title>
    <link href="http://thinerzq.com/2016/07/11/jvm%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/11/jvm学习报告/</id>
    <published>2016-07-11T01:08:06.000Z</published>
    <updated>2016-08-14T14:29:45.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><ol>
<li>程序计数器（Program Counter Register）：程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。</li>
<li>虚拟机栈（JVM Stack）：一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</li>
<li>本地方法栈（Native Method Statck）：本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，HotSpot会将本地方法栈与虚拟机栈放在一起使用。本地方法栈也是线程私有的。</li>
<li><p>堆区（Heap）：在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（基于逃逸分析，没有逃逸出方法体的对象，没有必要再堆上分配）。</p>
</li>
<li><p>方法区（Method Area）：方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。</p>
</li>
</ol>
<a id="more"></a>
<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><h2 id="垃圾对象的判断"><a href="#垃圾对象的判断" class="headerlink" title="垃圾对象的判断"></a>垃圾对象的判断</h2><p>Java 堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，有用与否又和引用的强弱有关。java将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，引用强度依次减弱。</p>
<ul>
<li>强引用：如“Object obj = new Object（）”，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用：SoftReference，它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。</li>
<li>弱引用：WeakReference，它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存岛下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
<li>虚引用：PhantomReference，最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<p>对象是否有用还和是否有对象还在继续引用它，将来还会不会被使用有关。判定对象是否为垃圾对象有如下算法：</p>
<p><strong>引用计数法</strong></p>
<p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1，当引用失效时，计数器值就减1，任何时刻计数器都为 0 的对象就是不可能再被使用的。</p>
<p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的选择，当 Java 语言并没有选择这种算法来进行垃圾回收，主要原因是它很难解决对象之间的相互循环引用问题。</p>
<p><strong>根搜索法</strong><br>Java 采用根搜索算法来判定对象是否存活的。这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，就证明此对象是不可用的。在 Java 语言里，可作为 GC Roots 的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中的常量引用的对象。</li>
<li>本地方法栈中 JNI（Native 方法）的引用对象。</li>
</ul>
<p>Java 中的垃圾回收一般是在 Java 堆中进行，因为堆中几乎存放了 Java 中所有的对象实例。</p>
<h2 id="收集算法"><a href="#收集算法" class="headerlink" title="收集算法"></a>收集算法</h2><p>当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法比较适合于新生代，将存活下来的少部分对象对象复制到另外一块空间。浪费空间</p>
<h3 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h3><p>标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。有内存碎片</p>
<h3 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h3><p>该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。成本较高，无内存碎片。</p>
<h2 id="可用的GC"><a href="#可用的GC" class="headerlink" title="可用的GC"></a>可用的GC</h2><h3 id="New-Generation-可用的GC"><a href="#New-Generation-可用的GC" class="headerlink" title="New Generation 可用的GC"></a>New Generation 可用的GC</h3><ul>
<li><p>Serial: 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。</p>
</li>
<li><p>Parallel Scavenge：它也是使用复制算法的收集器，又是并行的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。自适应（会动态调整SurvivorRatio的大小,也可以固定).</p>
</li>
<li><p>ParNew：ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。配合使用老年代的CMS</p>
</li>
</ul>
<h3 id="Old-Generation-可用的GC"><a href="#Old-Generation-可用的GC" class="headerlink" title="Old Generation 可用的GC"></a>Old Generation 可用的GC</h3><ul>
<li><p>Serial Old : Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记－整理算法。Serial Old收集器的主要意义也是在于给Client模式下的虚拟机使用。</p>
</li>
<li><p>Parallel Old：Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。</p>
</li>
<li><p>CMS：CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li>并发标记（CMS concurrent mark）：并发标记阶段就是进行GC Roots Tracing的过程。</li>
<li>重新标记（CMS remark）：重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要“Stop The World”。</li>
<li>并发清除（CMS concurrent sweep）：并发清除阶段会清除对象。</li>
</ul>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。另外CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生，同时也会产生大量的空间碎片</p>
</li>
<li><p>G1：G1（Garbage-First）是一款面向服务端应用的垃圾收集器。G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）：初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li>
<li>并发标记（Concurrent Marking）：并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记（Final Marking）：最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面。最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收（Live Data Counting and Evacuation）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ul>
</li>
</ul>
<h1 id="JVM内存状况查看方法和工具分析"><a href="#JVM内存状况查看方法和工具分析" class="headerlink" title="JVM内存状况查看方法和工具分析"></a>JVM内存状况查看方法和工具分析</h1><ol>
<li>输出GC日志：指定jvm启动参数，输出到控制台:-XX:PrintGC，-XX:PrintGCDetail。输出到指定的文件：-Xloggc:gc.log</li>
<li>GC Protal：输入GC日志文件，产生图形化的报表，部署麻烦，需要老版本jdk</li>
<li>JConsole：以图形化的方式查看JVM中内存你的变化状况</li>
<li>JVisualVM：查看内存的消耗状况，线程的执行状况以及程序中消耗cpu,内存的动作</li>
<li>JMap：JMap -heap pid 查看进程堆情况，JMap-histo pid 查看堆中对象的纤细占用情况，JMap -dump:format=b,file=文件名 pid：导出整个jvm的内存信息。</li>
<li>JHat：分析jvm dump的工具，和JMap搭配使用，JHat -J-Xmx2014M filename</li>
<li>JStat ：JStat -gcutil pid interval_time , 以一定的频率查看各代的占用情况</li>
</ol>
<h1 id="jvm-代码编译与执行"><a href="#jvm-代码编译与执行" class="headerlink" title="jvm 代码编译与执行"></a>jvm 代码编译与执行</h1><p>Java 虚拟机屏蔽了与具体操作系统平台相关的信息,使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时,实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<p>Java 代码编译和执行的整个过程包含了以下三个重要的机制：</p>
<ul>
<li>Java源码编译机制</li>
<li>类加载机制</li>
<li>类执行机制</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（运行时根据具体对象的类型进行绑定，ava 当中的方法只有 final，static，private 和构造方法是前期绑定的）。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>主要是找到class文件,并加载到jvm。通过类的全限定吗+对应的classloader一起标识一个加载的类。数组元素对应类型由classloader加载，数组类由jvm直接创建。在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中class文件元数据的访问入口。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证的目的是为了确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全（掌握了class文件的格式可以篡改class文件危害虚拟机）。主要包括如下四方面：</p>
<ul>
<li>文件格式的验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理（低版本不能处理高版本的），该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。</li>
<li>元数据的验证：其实就是对类中的各数据类型进行语法校验，保证不存在不符合 Java 语法规范的元数据信息。</li>
<li>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li>
<li>符号引用验证：它发生在虚拟机将符号引用转化为直接引用的时候，主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>初始化类中的静态成员变量，赋默认值，对static final 的常量赋指定的值</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池中的符号引用（就是各种class中所关联的其他类的名字，需要调用的方法，字段名字等）转化为直接引用（对应在内存中的的目标地址）的过程。虚拟机会根据需要（是否动态绑定，方法的修饰符等）来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。主要包括下面的几种解析</p>
<ul>
<li>类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</li>
<li>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。</li>
<li>类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，解析方法的时候先搜索父类，再搜索接口。</li>
<li>接口方法解析：递归向上搜索父接口就行了。</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>当一个Java类第一次被真正使用到的时候，JVM会进行该类的初始化操作。初始化过程的主要操作是执行静态代码块和初始化静态域。在一个类被初始化之前，它的直接父类也需要被初始化。但是，一个接口的初始化，不会引起其父接口的初始化。在初始化的时候，会按照源代码中从上到下的顺序依次执行静态代码块和初始化静态域。</p>
<p>虚拟机会保证一个类(不是对象)的<cinit>方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<cinit>方法，其他线程都需要阻塞等待，直到活动线程执行初始化方法完毕。如果在一个类的<cinit>方法中有耗时很长的操作，那就可能造成多个线程阻塞。有一种常见的单例模式就是这么实现的。</cinit></cinit></cinit></p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><h4 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h4><p>C++实现，<br>它负责加载存放在JDK\jre\lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的java.*开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。可以通过sun.misc.Launcher.getBootstrapClassPath().getURLs() 或者System.getProperty(“sun.boot.class.path”);  查看加载了哪些jar文件</p>
<h4 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h4><p>ExtClassLoader<br>载JDK\jre\lib\ext目录的所有jar，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如javax.*开头的类），</p>
<h4 id="System-ClassLoader"><a href="#System-ClassLoader" class="headerlink" title="System ClassLoader"></a>System ClassLoader</h4><p>AppClassLoader,<br>加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>继承java.lang.ClassLoader<br>重写父类的findClass(String 类的全限定名)方法<br>JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。这种方法确保了系统类的正确加载</p>
<h2 id="类执行机制"><a href="#类执行机制" class="headerlink" title="类执行机制"></a>类执行机制</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>jvm有自己的指令系统并使用于操作数栈的结构来解释执行指令。主要使用如下四种指令来执行一个方法</p>
<ul>
<li>invokestatic: static()方法</li>
<li>invokevirtual：实例方法</li>
<li>invokeinterface：接口方法</li>
<li>invokespecial：private和<init>方法</init></li>
<li>invokedynamic：jdk7中加入的动态语言支持</li>
</ul>
<h4 id="栈顶缓存"><a href="#栈顶缓存" class="headerlink" title="栈顶缓存"></a>栈顶缓存</h4><p>基于操作数栈的执行方式，很多操作都要讲值放入操作数栈，这导致了寄存器需要不断和类存交换数据，使用栈顶缓存将本来位于栈顶的值直接缓存在寄存器上。对于大部分只需要一个值的操作而言，无需将数据放入操作数栈，可直接在寄存器上计算，然后放回操作数栈。</p>
<h4 id="部分栈帧共享"><a href="#部分栈帧共享" class="headerlink" title="部分栈帧共享"></a>部分栈帧共享</h4><p>每个方法对应一个栈帧，当方法调用的时候，通常会传入参数到到另一个方法，而这个方法还位于前一个方法的操作数栈上。因此将前一个方法的操作数栈和当前方法的局部变量共享，节约了数据拷贝带来的开销。</p>
<h3 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h3><p>解释执行的效率比较低，为了提升代码性能，虚拟机将直接将大量循环执行代码编译为机器码（JIT）执行。根据硬件环境的不同，虚拟机会使用不同的编译方法，主要分为Client,Server模式。</p>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>只做了少量性能开销比较高的优化，主要针对方法块进行优化，适用于桌面交互式应用，虚拟机启动较快。</p>
<h5 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h5><p>把多个方法之间的调用，全部糅合到一个方法里面，消除了参数传递，返回值传递以及栈帧的开销。</p>
<h5 id="去虚拟化"><a href="#去虚拟化" class="headerlink" title="去虚拟化"></a>去虚拟化</h5><p>在装载class文件之后，进行类层次分析，如果发现类种的方法只提供了一个实现类，那么对于调用此方法的代码，也可以进行内联（有一个接口，只有一个实现类，使用了调用接口中方法的地方直接替换为接口实现类的方法）。</p>
<h5 id="冗余消除"><a href="#冗余消除" class="headerlink" title="冗余消除"></a>冗余消除</h5><p>在编译时候，根据运行时状况进行代码折叠或消除，比如static final 类型是静态常量值，编译的时候就能确定，所有在根据这个常量做一些判断的地方都直接削处了冗余的代码。</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>采用了大量的编译优化技巧来进行优化，更多的在于全局的优化，适用于服务端的应用，启动较慢。主要基于逃逸分析实现。</p>
<h5 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h5><p>用标量替换聚合量，如果创建的实体对象并未用到其中的全部变量，则将对象展开取出各个属性值单独定义，以后直接使用属性值。这样节省了一定的内存，而且无需去找对象的引用，也更快了。</p>
<h5 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h5><p>如果一个对象的新建是在一个方法里面，并且没有把这个方法的引用传出方法外面，那么这个对象就直接在栈上分配，好处是更加快速，而且随着方法的结束，对象也被回收了。</p>
<h5 id="同步消除"><a href="#同步消除" class="headerlink" title="同步消除"></a>同步消除</h5><p>如果发现同步的对象未逃逸，那就没有同步的必要的，直接去掉同步。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存布局&quot;&gt;&lt;a href=&quot;#内存布局&quot; class=&quot;headerlink&quot; title=&quot;内存布局&quot;&gt;&lt;/a&gt;内存布局&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;程序计数器（Program Counter Register）：程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。&lt;/li&gt;
&lt;li&gt;虚拟机栈（JVM Stack）：一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。&lt;/li&gt;
&lt;li&gt;本地方法栈（Native Method Statck）：本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，HotSpot会将本地方法栈与虚拟机栈放在一起使用。本地方法栈也是线程私有的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;堆区（Heap）：在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（基于逃逸分析，没有逃逸出方法体的对象，没有必要再堆上分配）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法区（Method Area）：方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://thinerzq.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://thinerzq.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java Io学习</title>
    <link href="http://thinerzq.com/2016/07/09/java%20Io%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/09/java Io学习报告/</id>
    <published>2016-07-09T01:08:06.000Z</published>
    <updated>2016-08-14T14:26:16.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Io概述"><a href="#Io概述" class="headerlink" title="Io概述"></a>Io概述</h1><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输介质将流抽象为各种类，方便更直观的进行数据操作。说白了这些类就是用来读取和写入数据的，由于可以读取或写入的媒介非常多，针对每一种媒介jdk提供了单独的类来读和写数据。同时根据读写单位又分为读取按字节读写和按字符读取(根据不同的编码方案,一个字符可能按多个字节读取)。大致可以分为如下</p>
<p>从读写介质的角度来看</p>
<table>
<thead>
<tr>
<th style="text-align:left">读写介质</th>
<th style="text-align:left">字节输入</th>
<th style="text-align:left">字节输出</th>
<th style="text-align:left">字符输入</th>
<th style="text-align:left">字符输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Basic</td>
<td style="text-align:left">InputStream</td>
<td style="text-align:left">OutputStream</td>
<td style="text-align:left">Reader, InputStreamReader</td>
<td style="text-align:left">Writer, OutputStreamReader</td>
</tr>
<tr>
<td style="text-align:left">Arrays</td>
<td style="text-align:left">ByteArrayInputStream</td>
<td style="text-align:left">ByteArrayOutputStream</td>
<td style="text-align:left">CharArrayReader</td>
<td style="text-align:left">CharArrayWriter</td>
</tr>
<tr>
<td style="text-align:left">File</td>
<td style="text-align:left">FileInputStream, RandomAccessFile</td>
<td style="text-align:left">FileOutputStream, RandomAccessFile</td>
<td style="text-align:left">FileReader</td>
<td style="text-align:left">FileWriter</td>
</tr>
<tr>
<td style="text-align:left">Pipes</td>
<td style="text-align:left">PipedInputStream</td>
<td style="text-align:left">PipedOutputStream</td>
<td style="text-align:left">PipedReader</td>
<td style="text-align:left">PipedWriter</td>
</tr>
<tr>
<td style="text-align:left">Buffering</td>
<td style="text-align:left">BufferedInputStream</td>
<td style="text-align:left">BufferedOutputStream</td>
<td style="text-align:left">BufferedReader</td>
<td style="text-align:left">BufferedWriter</td>
</tr>
<tr>
<td style="text-align:left">Filtering</td>
<td style="text-align:left">FilterInputStream</td>
<td style="text-align:left">FilterOuptStream</td>
<td style="text-align:left">FilterReader</td>
<td style="text-align:left">FilterWriter</td>
</tr>
<tr>
<td style="text-align:left">Parsing</td>
<td style="text-align:left">PushbackInputStream, StreamTokenizer</td>
<td style="text-align:left"></td>
<td style="text-align:left">PushbackReader, LineNumberReader</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">StringReader</td>
<td style="text-align:left">StringWriter</td>
</tr>
<tr>
<td style="text-align:left">Data</td>
<td style="text-align:left">DataInputStream</td>
<td style="text-align:left">DataOutputStream</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Data-Formatterd</td>
<td style="text-align:left"></td>
<td style="text-align:left">PrintStream</td>
<td style="text-align:left"></td>
<td style="text-align:left">PrintWriter</td>
</tr>
<tr>
<td style="text-align:left">Objects</td>
<td style="text-align:left">ObjectInputStream</td>
<td style="text-align:left">ObjectOutputStream</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Utilities</td>
<td style="text-align:left">SequenceInputStream</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>从功能和继承关系的角度看<br><img src="/images/java_io.png" alt="Java IO"></p>
<h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><p>InputStream类（不是接口）提供的基本方法<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>OutputStream类（不是接口）提供的基本方法<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>其他InputStream和OutputStream的子类都根据各自的功能重写了上述的方法或者提供了另外的函数</p>
<p>RandomAccessFile类提供的<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">long</span> pos)</span></span></div></pre></td></tr></table></figure></p>
<p>PipedInputStream类和PipedOutputStream类提供的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedOutputStream src)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedInputStream snk)</span></div></pre></td></tr></table></figure>
<p>DataInputStream类提供的一系列方法，DataOutputStream提供的方法也类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span>&#123;</div><div class="line">  <span class="comment">//in 是通过DataInputStream的构造函数传递进去的InputStream具体类的对象</span></div><div class="line">  <span class="keyword">int</span> ch1 = in.read();</div><div class="line">  <span class="keyword">int</span> ch2 = in.read();</div><div class="line">  <span class="keyword">int</span> ch3 = in.read();</div><div class="line">  <span class="keyword">int</span> ch4 = in.read();</div><div class="line">  <span class="keyword">if</span> ((ch1 | ch2 | ch3 | ch4) &lt; <span class="number">0</span>)</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">  <span class="keyword">return</span> ((ch1 &lt;&lt; <span class="number">24</span>) + (ch2 &lt;&lt; <span class="number">16</span>) + (ch3 &lt;&lt; <span class="number">8</span>) + (ch4 &lt;&lt; <span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">readLine</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>PushbackInputStream提供的unread()方法其实很简单，使用一个buf数组，将unread的字节放入buf，下次read的时候从buf里面读。PushbackReader原理类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="keyword">if</span> (pos &lt; buf.length) &#123;</div><div class="line">        <span class="keyword">return</span> buf[pos++] &amp; <span class="number">0xff</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.read();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</div><div class="line">    &#125;</div><div class="line">    buf[--pos] = (<span class="keyword">byte</span>)b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SequenceInputStream把一个或者多个InputStream整合起来，形成一个逻辑连贯的输入流。当读取SequenceInputStream时，会先从第一个输入流中读取，完成之后再从第二个输入流读取… 以此类推。程序内部将多个流放入到一个Enumeration中，在read的时候判断需不需要切换到下一个流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequenceInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</div><div class="line">    Enumeration&lt;? extends InputStream&gt; e;</div><div class="line">    InputStream in;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SequenceInputStream</span><span class="params">(Enumeration&lt;? extends InputStream&gt; e)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.e = e;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            nextStream();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">            <span class="comment">// This should never happen</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"panic"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">nextStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</div><div class="line">       in.close();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (e.hasMoreElements()) &#123;</div><div class="line">       in = (InputStream) e.nextElement();</div><div class="line">       <span class="keyword">if</span> (in == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span> in = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">while</span> (in != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> c = in.read();</div><div class="line">        <span class="keyword">if</span> (c != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> c;</div><div class="line">        &#125;</div><div class="line">        nextStream();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PrintStream允许你把格式化数据写入到底层OutputStream中。比如，写入格式化成文本的int，long以及其他原始数据类型到输出流中，而非它们的字节数据。通过其内部的构造方法可以看出，这个流内部其实用了Writer来写int ,long 类型的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">PrintStream</span><span class="params">(<span class="keyword">boolean</span> autoFlush, OutputStream out, Charset charset)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(out);</div><div class="line">        <span class="keyword">this</span>.autoFlush = autoFlush;</div><div class="line">        <span class="keyword">this</span>.charOut = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">this</span>, charset);</div><div class="line">        <span class="keyword">this</span>.textOut = <span class="keyword">new</span> BufferedWriter(charOut);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        write(String.valueOf(i));</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">             ensureOpen();</div><div class="line">             textOut.write(s);</div><div class="line">             textOut.flushBuffer();</div><div class="line">             charOut.flushBuffer();</div><div class="line">             <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>))</div><div class="line">                 out.flush();</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">catch</span> (InterruptedIOException x) &#123;</div><div class="line">         Thread.currentThread().interrupt();</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">         trouble = <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>从PrintWriter的最终的构造方法可以看出，PrintWriter内部只使用Wrtier来作为最终的输出流。它提供的方法和PrintStream基本一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(Writer out,<span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(out);</div><div class="line">        <span class="keyword">this</span>.out = out;</div><div class="line">        <span class="keyword">this</span>.autoFlush = autoFlush;</div><div class="line">        lineSeparator = java.security.AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out)), autoFlush);</div><div class="line"></div><div class="line">     <span class="comment">// save print stream for error propagation</span></div><div class="line">     <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintStream) &#123;</div><div class="line">         psOut = (PrintStream) out;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">      write(String.valueOf(l));</div><div class="line">  &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            ensureOpen();</div><div class="line">            out.write(s, off, len);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</div><div class="line">        Thread.currentThread().interrupt();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">        trouble = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LineNumberReader类通过getLineNumber()方法获取当前行号，通过setLineNumber()方法设置当前行数。流的读取依然是顺序进行，不能通过setLineNumber()实现流的跳跃读取。使用这个流可以快速定位流读取过程中出现的错误。这个流的本质就是在读取的时候使用判断读到的字符是否是行结束符，如果是就lineNumber++（文件的行结束符视操作系统而定）。这个流没有LineNumberInputStream一说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="keyword">int</span> c = <span class="keyword">super</span>.read();</div><div class="line">            <span class="keyword">if</span> (skipLF) &#123;</div><div class="line">                <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</div><div class="line">                    c = <span class="keyword">super</span>.read();</div><div class="line">                skipLF = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">switch</span> (c) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'\r'</span>:</div><div class="line">                skipLF = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:          <span class="comment">/* Fall through */</span></div><div class="line">                lineNumber++;</div><div class="line">                <span class="keyword">return</span> <span class="string">'\n'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> c;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>StreamTokenizer通过循环调用nextToken()可以遍历底层输入流的所有符号。在每次调用nextToken()之后，StreamTokenizer有一些变量可以获取读取到的符号的类型和值。这些变量是：</p>
<ol>
<li>ttype 读取到的符号的类型(字符(TT_WORD)，数字(TT_NUMBER)，或者行结尾符(TT_EOL))</li>
<li>sval 如果读取到的符号是字符串类型，该变量的值就是读取到的字符串的值</li>
<li>nval 如果读取到的符号是数字类型，该变量的值就是读取到的数字的值</li>
</ol>
<p>以此类推，只要在需要的什么样的流的时候，使用对应的io流对象就行了。说到io，大家都会想到装饰器模式，其实装饰器模式很好理解。下面三个类就是io中一个简单的装饰器模式体现。使用io流的时候，主要注意的问题是几个对象之间能不能互相装饰。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.in = in;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> in.read();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        in.reset();</div><div class="line">    &#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">         <span class="keyword">super</span>(in);</div><div class="line">         buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">       <span class="keyword">if</span> (pos &gt;= count) &#123;</div><div class="line">           fill();</div><div class="line">           <span class="keyword">if</span> (pos &gt;= count)</div><div class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        getBufIfOpen(); <span class="comment">// Cause exception if closed</span></div><div class="line">        <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Resetting to invalid mark"</span>);</div><div class="line">        pos = markpos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> <span class="keyword">implements</span> <span class="title">DataInput</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</div><div class="line">         <span class="keyword">super</span>(in);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">      <span class="keyword">int</span> ch = in.read();</div><div class="line">      <span class="keyword">if</span> (ch &lt; <span class="number">0</span>)</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">      <span class="keyword">return</span> (ch != <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//没有reset(),mark()方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想使用DataInputStream 同时使用BufferedInputStream的mark()方法，可以如下使用<br>DataInputStream dis = new DataInputStream(new BufferedInputStream(new FileInputStream(“filepath”)));</p>
<h1 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h1><ol>
<li><p>任何关于文件本身或者目录的操作在File类里面</p>
</li>
<li><p>int read()和 int read(byte[] b)方法返回值的区别<br>read()放回读取到的字节，read(byte[] b)返回读取到的字节数量。</p>
</li>
<li><p>System.out System.in. System.err 可以通过System.setErr()等重定向到任意输出流，</p>
</li>
<li><p>流关闭问题的两种解决方法，一统一写一个模板类，二使用try-with-resource风格编程</p>
</li>
<li><p>BufferedInputStream和BufferedOutputStream缓冲区大小设置为1024整数倍效率更高</p>
</li>
<li><p>ObjectInputStream和ObjectOutputStream所读写的对象对应的类必须实现了java.io.Serializable接口</p>
</li>
<li><p>InputStreamReader和OutputStreamWriter是一种字符流，主要目的是将字节流转化成字符流，使用字符流的形式来处理数据。</p>
</li>
<li><p>FilterInputStream和和FilterOuFilterReader和FilterReader是过滤流的基类， 都只是简单的覆盖了其父类的方法，主要使用它们的子类来处理读写。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Io概述&quot;&gt;&lt;a href=&quot;#Io概述&quot; class=&quot;headerlink&quot; title=&quot;Io概述&quot;&gt;&lt;/a&gt;Io概述&lt;/h1&gt;&lt;p&gt;流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输介质将流抽象为各种类，方便更直观的进行数据操作。说白了这些类就是用来读取和写入数据的，由于可以读取或写入的媒介非常多，针对每一种媒介jdk提供了单独的类来读和写数据。同时根据读写单位又分为读取按字节读写和按字符读取(根据不同的编码方案,一个字符可能按多个字节读取)。大致可以分为如下&lt;/p&gt;
&lt;p&gt;从读写介质的角度来看&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;读写介质&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;字节输入&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;字节输出&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;字符输入&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;字符输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Basic&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;InputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;OutputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Reader, InputStreamReader&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Writer, OutputStreamReader&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Arrays&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;ByteArrayInputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;ByteArrayOutputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;CharArrayReader&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;CharArrayWriter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;File&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;FileInputStream, RandomAccessFile&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;FileOutputStream, RandomAccessFile&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;FileReader&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;FileWriter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Pipes&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PipedInputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PipedOutputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PipedReader&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PipedWriter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Buffering&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;BufferedInputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;BufferedOutputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;BufferedReader&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;BufferedWriter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Filtering&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;FilterInputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;FilterOuptStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;FilterReader&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;FilterWriter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Parsing&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PushbackInputStream, StreamTokenizer&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PushbackReader, LineNumberReader&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;String&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;StringReader&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;StringWriter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Data&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DataInputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DataOutputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Data-Formatterd&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PrintStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PrintWriter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Objects&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;ObjectInputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;ObjectOutputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Utilities&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;SequenceInputStream&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="java" scheme="http://thinerzq.com/categories/java/"/>
    
    
      <category term="io" scheme="http://thinerzq.com/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO学习</title>
    <link href="http://thinerzq.com/2016/07/09/java%20nio%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/09/java nio学习报告/</id>
    <published>2016-07-09T01:08:06.000Z</published>
    <updated>2016-08-14T14:28:02.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO概述"><a href="#NIO概述" class="headerlink" title="NIO概述"></a>NIO概述</h1><p>Java NIO: Non-blocking IO（非阻塞IO）是jdk 1.4提出的，简单的理解就是使用nio api读写数据的时候不会等待把所有数据读写完再返回(所以读写的时候应该使用while循环不断尝试读写数据)。NIO中关键的三个概念是通道，缓冲区，选择器。</p>
<a id="more"></a>
<h2 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel(通道)"></a>Channel(通道)</h2><p>所有的数据读写在NIO 中都从Channel 开始，可以把Channel想象成io 中的Stream。数据是从Channel读到Buffer中，或者从Buffer 写到Channel中。Channel主要有以下几种</p>
<ol>
<li>FileChannel: 从FileInputStream和FileOutputStream打开的文件通道</li>
<li>DatagramChannel：通过UDP协议读写网络中的数据</li>
<li>SocketChannel：通过TCP协议读写网络中的数据</li>
<li>ServerSocketChannel：对每一个连接创建一个SocketChannel</li>
</ol>
<h2 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer(缓冲区)"></a>Buffer(缓冲区)</h2><p>读取数据的第一步是Channel，第二步是Buffer。数据从通道读取到Buffer中，然后再使用，或者从Buffer中写入通道。Buffer本质上是一块可以写入数据，然后可以从中读取数据的内存,这块内存被包装成NIO Buffer对象。</p>
<p>Buffer主要由三个属性，它们决定了每次读写缓冲区的什么位置。</p>
<ol>
<li>capacity：缓冲区的大小</li>
<li>position：读模式的时候，position为下一个可以读取的位置；写模式的时候，position为下一个可以写入数据的位置</li>
<li>limit：写模式的时候，可以写入的数据的大小；读模式下，limit表示可以读取的数据大小</li>
</ol>
<p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式（相应的position和limit值会改变）。在读模式下，可以读取之前写入到buffer的所有数据。</p>
<p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。clear()将Buffer中剩余的数据清除，compact()会将没有读取的数据移动到Buffer起始处，之后还可以读取。</p>
<p>Buffer.allocate() 直接在Head上分配内存，Buffer.directAllocate()在堆外分配内存（分配的内存不受GC影响，需要自己手动释放）。</p>
<h2 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector(选择器)"></a>Selector(选择器)</h2><p>Selector（选择器）是NIO中能够侦听多个NIO Channel，并能够知晓这些Channel是否为特定的事件做好准备的组件。<br>Selector的使用主要是通过如下这种形式来使用<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</div><div class="line">ServerSocket ss = ssChannel.socket();</div><div class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">ss.bind(address);</div><div class="line"></div><div class="line">Selector selector = Selector.open();</div><div class="line"></div><div class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT); <span class="comment">//向selector注册监听连接请求</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    selector.select();<span class="comment">//阻塞 直到某个channel注册的感兴趣的事件被触发</span></div><div class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">    <span class="keyword">for</span> (SelectionKey key : keys) &#123;</div><div class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">//客户端连接请求</span></div><div class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</div><div class="line">            SocketChannel sc = ssc.accept();</div><div class="line">            sc.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            sc.register(selector, SelectionKey.OP_READ); <span class="comment">//向selector注册监听客户端输入</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">//客户端输入</span></div><div class="line"></div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">            SocketChannel socketChannel = (SocketChannel) key.channel();</div><div class="line"></div><div class="line">            <span class="comment">// 针对当前连接做一些事情.read or write</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    keys.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Selector必须和Channel配合使用，而且Channel必须处于非阻塞模式下。通过resigter()方法绑定selector和channel的时候，第二个参数指定了当前channel对什么事件感兴趣。一个channel可以有如下4种感兴趣的事件</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>当channel向selector注册了事件之后，selector.selector()方法会阻塞直到channel关心的哪些事件已经就绪。事件就绪之后判断事件的类别，根据不同类别分别做不同的读写处理。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<p>对应的流是ObjectOutputStream，ObjectInputStream。static变量, transient不会序列化，static final会序列化。实现这两个接口的类可以序列化：Serializible ,Externalizible。</p>
<p>如果想自己控制一部分序列化的过程，可以在需要序列化的类种加入private级别的readObject()和writeObject()方法，这两个方法再ObjectInputStream和ObjectOutputStream中会反射调用。write和read的顺序必须一致。使用实现Externalizible接口来序列化，序列化的过程完全可控。</p>
<p>如果需要序列化的对象使用了Signleton模式，（序列化前的对象 == 序列化后的对象）=false,如果要使这两者相等，可以在Singleton类种加入readResolve()方法，在这个方法中返回Signleton对象替换掉在流中创建的对象。——这些都是在同一个jvm中才有用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NIO概述&quot;&gt;&lt;a href=&quot;#NIO概述&quot; class=&quot;headerlink&quot; title=&quot;NIO概述&quot;&gt;&lt;/a&gt;NIO概述&lt;/h1&gt;&lt;p&gt;Java NIO: Non-blocking IO（非阻塞IO）是jdk 1.4提出的，简单的理解就是使用nio api读写数据的时候不会等待把所有数据读写完再返回(所以读写的时候应该使用while循环不断尝试读写数据)。NIO中关键的三个概念是通道，缓冲区，选择器。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://thinerzq.com/categories/java/"/>
    
    
      <category term="nio" scheme="http://thinerzq.com/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础学习</title>
    <link href="http://thinerzq.com/2016/07/09/spring%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/09/spring学习报告/</id>
    <published>2016-07-09T01:08:06.000Z</published>
    <updated>2016-08-14T14:30:24.271Z</updated>
    
    <content type="html"><![CDATA[<p>通常说的Spring其实指的是Spring Framework，它是Spring下的一个子项目，Spring围绕Spring Framework这个核心项目开发了大量其他项目，比如Spring Security，Spring Data，Spring Boot等. Spring Framework包括他的核心解决方案IoC容器、 AOP。</p>
<a id="more"></a>
<h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>所谓控制反转，是指通过使用IoC容器对象依赖关系的管理被反转了，也就是说，对象之间的依赖关系由IoC容器进行管理，并且由Ioc容器通过依赖注入（DI，Dependency Injection）的方式来完成对象的注入（以前一个对象需要new了才能使用，现在你只要声明就行了，spring会帮你new好了，在你需要的时候把这个对象的引用传递给你）。</p>
<p>整个依赖入住的过程中，有一个问题如何解决循环依赖的对象的注入：构造器循环依赖是无法解决的，只有单例模式下的setter注入可以解决（通过将new完了，还未调用其setter方法的bean放入到Map中，从而使其他Bean能引用到该Bean）</p>
<h1 id="切面编程"><a href="#切面编程" class="headerlink" title="切面编程"></a>切面编程</h1><p>面向切面编程（AOP）通过提供另外一种思考程序结构的途经来弥补面向对象编程（OOP）的不足。在OOP中模块化的关键单元是类（classes），而在AOP中模块化的单元则是切面。切面能对关注点进行模块化，例如横切多个类型和对象的事务管理。Aop中有一些核心概念：</p>
<ul>
<li>横切性关注点：对哪些方法拦截，拦截后怎么处理，这些关注就称之为横切性关注点.<br>Aspect（切面）：指横切性关注点的抽象即为切面，它与类相似，只是两者的关注点不一样，类是对物体特征的抽象，而切面是横切性关注点的抽象。</li>
<li>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点，实际上joinpoint还可以是field或类构造器。</li>
<li>Pointcut(切入点)：所谓切入点是指我们要对那些joinpoin进行拦截的定义。</li>
<li>Advice（通知）：所谓通知是指拦截到joinpoint之后所要做的事情就是通知。通知分为前置通知，后置通知，异常通知，最终通知，环绕通知。<ul>
<li>前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</li>
<li>后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li>
<li>异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li>
<li>最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li>
<li>环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</li>
</ul>
</li>
<li>Target（目标对象）：代理的目标对象</li>
<li>Weave(织入)：指将aspects应用到target对象并导致proxy对象创建的过程称为织入。</li>
</ul>
<p>由于开启了切面编程功能，所以当获取一个被切面类监控管理的bean对象时，它实际上获取的是此对象的一个代理对象，而在spring中对代理对象的处理有如下原则：（1）如果要代理的对象实现了接口，则会按照Proxy的方式来产生代理对象，这即是说产生的代理对象只能是接口类型。如果要代理的对象未实现接口，则按cglib方式来产生代理对象。<br>要想spring的切面技术起作用，被管理的bean对象只能是通过spring容器获取的对象。</p>
<h1 id="事物管理"><a href="#事物管理" class="headerlink" title="事物管理"></a>事物管理</h1><p>在 Spring 中，事务是通过 TransactionDefinition 接口来定义的。接口只提供了获取事物隔离级别，传播行为，超时时间的方法</p>
<h2 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h2><p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
</ul>
<h2 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h2><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p>
<p>通常情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。如果没有抛出任何异常，或者抛出了已检查异常，则仍然提交事务</p>
<p>基于 @Transactional 的声明式事务管理，可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，也可以在方法级别使用该标注来覆盖类级别的定义。， @Transactional 注解应该只被应用到 public 方法上，如果在protected、private 或者默认可见性的方法上使用 @Transactional 注解，将被忽略，也不会抛出任何异常。</p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自已定义，把拦截下来的请求，依据相应的规则分发到目标Controller来处理，是配置spring MVC的第一步。</p>
<p>Controller：具体处理请求的控制器。日常功能都在Controller 中处理</p>
<p>handlerMapping：映射处理器。负责映射中央处理器转发给 Controller时的映射策略，即DispatcherServlet按什么规则去寻找需要访问的</p>
<p>Controller。需要在spring-mvc的配置文件中配置。主要有三种类型，分别为为按Controller控制器的名称、类型和简单url隐射。默认为按Controller的名称（可省略）</p>
<p>ModelAndView：服务层返回的数据和视图层的封装类,用来封装 Controller 需要访问的视图(view)和传输的数据(model)，一般在控制器Controller  中自己实现处理。</p>
<p>ViewResolver &amp; View：视图解析器.需要在spring-mvc的配置文件中配置，一般分为前缀与后缀。前缀：webroot到某一指定的文件夹的路径；后缀：视图名称的后缀。然后和 ModelAndView 中的view结合使用，确认具体的访问视图。</p>
<p>Interceptors ：拦截器,负责拦截我们定义的请求然后做处理工作。</p>
<p>运行原理：</p>
<ol>
<li>客户端请求提交到DispatcherServlet；</li>
<li>由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller；</li>
<li>DispatcherServlet将请求提交到Controller；</li>
<li>Controller调用业务逻辑处理后，返回ModelAndView；</li>
<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图；</li>
<li>视图负责将结果显示到客户端。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常说的Spring其实指的是Spring Framework，它是Spring下的一个子项目，Spring围绕Spring Framework这个核心项目开发了大量其他项目，比如Spring Security，Spring Data，Spring Boot等. Spring Framework包括他的核心解决方案IoC容器、 AOP。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://thinerzq.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://thinerzq.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程学习</title>
    <link href="http://thinerzq.com/2016/07/09/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://thinerzq.com/2016/07/09/java多线程学习报告/</id>
    <published>2016-07-09T01:08:06.000Z</published>
    <updated>2016-08-14T14:28:18.696Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>ConcurrentHashMap：线程安全HashMap，分段锁。put(),remove()加锁，size()三次后再加锁</p>
</li>
<li><p>CopyOnWriteArrayList：线程安全，读无锁的ArrayList,使用ReentrantLock, 每次add，remove都是新创建一个数组，复制元素到新的数组，最后切换全局数组引用。适用于多读少写</p>
</li>
<li><p>CopyOnWriteArraySet：通过CopyOnWriteSet实现，add()的时候会遍历整个数组判断数组是否存在这个值，因此性能略低于CopyOnWriteArrayList</p>
</li>
<li><p>ArrayBlockingQueue： 基于数组，ReentrantLock,Condition实现的有界队列。add(E e):队满，抛异常。put(E e):队满，阻塞。offer(E e):队满，返回false。remove()，take()，poll()。和上面对应。</p>
</li>
<li><p>LinkedBlockingQueue：基于链表，读写锁分离，遍历同时锁。此按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。</p>
</li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。</p>
</li>
<li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p>
</li>
<li><p>Atomic：支持原子操作的类，由硬件指令cmpxchg提供CAS支持（简单来说，先使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与期望的值相等，就使用一个新值替换当前变量的值）,比synchronize性能高出2倍。实现类有AtomicBoolean，AtomicInteger，AtomicIntegerArray，AtomicLong，AtomicLongArray，AtomicReference，AtomicReferenceArray等。需要注意的是ABA问题，可以通过AtomicStampedReference解决。</p>
</li>
<li><p>线程池<br>线程池就是有一堆线程，随时可以取一个线程出来用。学习线程池最好的方法就是从线程池的构造函数开始看。一个线程池的关注点在构造函数中的几个参数。常用的Executor类的几个方法都是返回一个的ThreadPoolExecutor，这些ThreadPoolExecutor的构造函数的参数各不相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,  BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">            maximumPoolSize &lt; corePoolSize ||</div><div class="line">            keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">        <span class="keyword">this</span>.handler = handler;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>corePoolSize： 线程池维护线程的最少数量：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</p>
</li>
<li><p>maximumPoolSize：线程池维护线程的最大数量：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用了无界的任务队列这个参数就没什么效果。</p>
</li>
<li><p>keepAliveTime： 线程池维护线程所允许的空闲时间：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p>
</li>
<li><p>unit： 线程池维护线程所允许的空闲时间的单位：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</p>
</li>
<li><p>workQueue： 线程池所使用的缓冲队列。</p>
</li>
<li><p>threadFactory：线程池创建线程的工厂：可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p>
</li>
<li><p>handler： 线程池对拒绝任务的处理策略：AbortPolicy：直接抛出异常。<br>CallerRunsPolicy：只用调用者所在线程来运行任务。<br>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。<br>DiscardPolicy：不处理，丢弃掉。<br>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</p>
</li>
</ol>
</li>
<li><p>Executors：对ThreadPoolExecutor再封装。</p>
<ol>
<li><p>nexFixedThreadPool(int) :直接创建固定大小的线程池，keepAlive=0，超过LinkedBlockingQueue的最大范围拒绝</p>
</li>
<li><p>newSingleThreadExecutor:线程只有1个，其他的等待</p>
</li>
<li><p>newCachedThreadPool:corePoolSize=0,keepAlive=60s,SynchronousQueue,最大线程未Integer.Max_Value</p>
</li>
<li><p>newScheduledThreadPool(int):DelayedWorkQueue:会对新加入的任务按照执行时间排序</p>
</li>
</ol>
</li>
<li><p>FutureTask：异步获取执行结果，保证只执行一次，可取消任务。</p>
</li>
<li>Semaphore：控制某资源同时被访问的个数的类，通过构造函数可以达到公平访问和非公平访问，默认非公平。如果把资源那个数设置为1,可以达到锁的效果。</li>
<li>CountDownLatch：用于多个线程同时开始某一个动作，每个线程执行的时候，计数器-1，如果计数器为0，位于latch.await()后面代码才会执行。一般用来等待任务执行完毕</li>
<li><p>CyclicBarrier: 和CountDownLatch刚好反过来，它是当await()的数量达到一定，才继续往后执行，另外还能设置一个回调：当await()达到一定数量后，开始执行回调的Runable对象</p>
</li>
<li><p>ReentrantLock：ReentrantLock提供了公平锁和非公平锁，lock().trylock(),trylockInterrupted, tryLock(time)等方法</p>
</li>
<li><p>Condition： 一般和RenentrantLock配合使用，可在同一个锁上启用多个Condition,用于等待，通知操作。</p>
</li>
<li><p>和ReentrantLock没有任何继承关系    ，提供了读写锁分离。读的时候如果没有线程写就直接获取，读操作是无阻赛的。写的时候如果有其他线程在读或者写就会被阻塞。在同一线程中，持有读锁后不能调用写锁的lock方法（会死锁）：读锁不可升级。同一个线程中，持有写锁后，可以调用读锁的lock方法，之后如果调用写锁的unlock(0方法，当前锁降级为读锁。适用于读多写少</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;ConcurrentHashMap：线程安全HashMap，分段锁。put(),remove()加锁，size()三次后再加锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CopyOnWriteArrayList：线程安全，读无锁的ArrayList,使用Reent
    
    </summary>
    
      <category term="java" scheme="http://thinerzq.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://thinerzq.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux里面一些文件或者目录的作用</title>
    <link href="http://thinerzq.com/2016/05/29/linux%E9%87%8C%E9%9D%A2%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://thinerzq.com/2016/05/29/linux里面一些文件或目录的作用/</id>
    <published>2016-05-29T12:58:06.000Z</published>
    <updated>2016-05-30T16:09:49.782Z</updated>
    
    <content type="html"><![CDATA[<p>linux里面文件或者目录作用索引表</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">文件</th>
<th style="text-align:center">目录</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">全名</th>
<th style="text-align:center">适用于什么distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/ect/fstab</td>
<td style="text-align:center"></td>
<td style="text-align:center">文件系统表，配置开机需要挂载的分区，mount挂载分区写入参数到这个文件，添加了dump的支持</td>
<td style="text-align:center">filesystem table</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/mtab</td>
<td style="text-align:center"></td>
<td style="text-align:center">实际存放文件系统挂载信息的地方</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux里面文件或者目录作用索引表&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://thinerzq.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://thinerzq.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql存储引擎</title>
    <link href="http://thinerzq.com/2016/05/10/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://thinerzq.com/2016/05/10/mysql存储引擎/</id>
    <published>2016-05-10T13:22:44.000Z</published>
    <updated>2016-05-30T16:01:53.530Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>mysql&gt; select version();<br>+—————–+<br>| version()       |<br>+—————–+<br>| 5.7.12-0ubuntu1 |<br>+—————–+</p>
</blockquote>
<a id="more"></a>
<p><strong>mysql支持的存储引擎</strong></p>
<blockquote>
<p>mysql&gt; SHOW ENGINES;</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">Engine</th>
<th style="text-align:center">Support</th>
<th style="text-align:center">Comment</th>
<th style="text-align:center">Transactions</th>
<th style="text-align:center">XA</th>
<th style="text-align:center">Savepoints</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CSV</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">CSV storage engine</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">MRG_MYISAM</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">Collection of identical MyISAM tables</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">MyISAM</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">MyISAM storage engine</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">BLACKHOLE</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">/dev/null storage engine (anything you write to it disappears)</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">PERFORMANCE_SCHEMA</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">Performance Schema</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">InnoDB</td>
<td style="text-align:center">DEFAULT</td>
<td style="text-align:center">Supports transactions, row-level locking, and foreign keys</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">ARCHIVE</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">Archive storage engine</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">MEMORY</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">Hash based, stored in memory, useful for temporary tables</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">FEDERATED</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">Federated MySQL storage engine</td>
<td style="text-align:center">NULL</td>
<td style="text-align:center">NULL</td>
<td style="text-align:center">NULL</td>
</tr>
</tbody>
</table>
<h1 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h1><p>MyISAM是mysql5.5之前默认的存储引擎，不支持失误，页不支持外键，访问速度快，适用于对事物完整性没有要求，或者以Select,Insert为主的应用。</p>
<p>MyISAM支持3种不同的存储格式：</p>
<ol>
<li>静态表（字段长度固定）</li>
<li>动态表（字段长度不固定</li>
<li>压缩表</li>
</ol>
<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><p>InnoDB提供了具有，提交，回滚，崩溃能力恢复的事物安全。但是对比MyISAM,InnoDB的处理效率差一些，会占用更多的磁盘空间以保留数据和索引。</p>
<h2 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h2><p>可以手动插入，如果插入的值为空，或者为0，则实际插入的值为自动增长后的值。自动增长列必须是索引，如果是组合索引，页必须是组合索引的第一列，对于MyISAM，自动增长列可以是组合所应的其他列。</p>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>只有InnoDB</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;mysql&amp;gt; select version();&lt;br&gt;+—————–+&lt;br&gt;| version()       |&lt;br&gt;+—————–+&lt;br&gt;| 5.7.12-0ubuntu1 |&lt;br&gt;+—————–+&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://thinerzq.com/categories/mysql/"/>
    
    
      <category term="mysql 存储引擎" scheme="http://thinerzq.com/tags/mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>linux命令大全</title>
    <link href="http://thinerzq.com/2016/05/06/linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://thinerzq.com/2016/05/06/linux命令大全/</id>
    <published>2016-05-06T05:34:00.000Z</published>
    <updated>2016-05-29T13:21:38.394Z</updated>
    
    <content type="html"><![CDATA[<p>主要是为了通过命令的目的或者全名，理解记忆各个命令的功能</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">全名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">startX</td>
<td style="text-align:center">在tty下面开启图形化界面</td>
<td style="text-align:center">个人感觉应该是start X Window</td>
</tr>
<tr>
<td style="text-align:center">exit</td>
<td style="text-align:center">退出当前登陆的用户</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">显示当前日期时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">echo</td>
<td style="text-align:center">输出一组值</td>
</tr>
<tr>
<td style="text-align:center">cal</td>
<td style="text-align:center">日历</td>
<td style="text-align:center">calendar</td>
</tr>
<tr>
<td style="text-align:center">bc</td>
<td style="text-align:center">简单的计算器，支持（+，-，×，/，^,%）</td>
<td style="text-align:center">bash calculator</td>
</tr>
<tr>
<td style="text-align:center">tab</td>
<td style="text-align:center">自动补全</td>
</tr>
<tr>
<td style="text-align:center">ctrl+c</td>
<td style="text-align:center">种植程序</td>
</tr>
<tr>
<td style="text-align:center">man</td>
<td style="text-align:center">帮助手册</td>
<td style="text-align:center">manual</td>
</tr>
<tr>
<td style="text-align:center">/word,?word</td>
<td style="text-align:center">查找，n,N向上向下</td>
</tr>
<tr>
<td style="text-align:center">whatis</td>
<td style="text-align:center">查找某一个命令是什么,等于 man -f</td>
<td style="text-align:center">what is</td>
</tr>
<tr>
<td style="text-align:center">info</td>
<td style="text-align:center">功能和man差不多，提供了文件节点的能力</td>
<td style="text-align:center">information</td>
</tr>
<tr>
<td style="text-align:center">/usr/share/doc/..</td>
<td style="text-align:center">存放了各个命令的说明</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">nano</td>
<td style="text-align:center">文本编辑</td>
<td style="text-align:center">//TODO</td>
</tr>
<tr>
<td style="text-align:center">who</td>
<td style="text-align:center">当前有谁在线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">netstat -a</td>
<td style="text-align:center">当前网络情况</td>
<td style="text-align:center">netstat</td>
</tr>
<tr>
<td style="text-align:center">ps -aux</td>
<td style="text-align:center">进程相关</td>
<td style="text-align:center">process snapshot</td>
</tr>
<tr>
<td style="text-align:center">shutdown</td>
<td style="text-align:center">关机，重启</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">reboot</td>
<td style="text-align:center">重启</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">halt</td>
<td style="text-align:center">关机</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">poweroff</td>
<td style="text-align:center">关机</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">sync</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">Synchronize</td>
</tr>
<tr>
<td style="text-align:center">fsck</td>
<td style="text-align:center">磁盘扫描检查修复</td>
<td style="text-align:center">filesystem scan check and repair</td>
</tr>
<tr>
<td style="text-align:center">ls -al</td>
<td style="text-align:center">列出文件</td>
<td style="text-align:center">list</td>
</tr>
<tr>
<td style="text-align:center">chgrp</td>
<td style="text-align:center">更改文件所在组</td>
<td style="text-align:center">change group</td>
</tr>
<tr>
<td style="text-align:center">chown</td>
<td style="text-align:center">更改文件所有者</td>
<td style="text-align:center">change owner</td>
</tr>
<tr>
<td style="text-align:center">chmod</td>
<td style="text-align:center">更改文件权限</td>
<td style="text-align:center">change mode</td>
</tr>
<tr>
<td style="text-align:center">uname -r</td>
<td style="text-align:center">查看内核版本</td>
<td style="text-align:center">//TODO</td>
</tr>
<tr>
<td style="text-align:center">lsb_release -a</td>
<td style="text-align:center">查看distribution信息</td>
<td style="text-align:center">//TODO</td>
</tr>
<tr>
<td style="text-align:center">cd</td>
<td style="text-align:center">切换目录</td>
<td style="text-align:center">change Directory</td>
</tr>
<tr>
<td style="text-align:center">pwd</td>
<td style="text-align:center">显示当前目录</td>
<td style="text-align:center">print working Directory</td>
</tr>
<tr>
<td style="text-align:center">mkdir</td>
<td style="text-align:center">新建目录</td>
<td style="text-align:center">make Directory</td>
</tr>
<tr>
<td style="text-align:center">rmdir</td>
<td style="text-align:center">删除一个空目录</td>
<td style="text-align:center">remove Directory</td>
</tr>
<tr>
<td style="text-align:center">cp</td>
<td style="text-align:center">拷贝，文件属性不变</td>
<td style="text-align:center">copy</td>
</tr>
<tr>
<td style="text-align:center">rm</td>
<td style="text-align:center">删除文件</td>
<td style="text-align:center">remove</td>
</tr>
<tr>
<td style="text-align:center">mv</td>
<td style="text-align:center">移动文件,更改文件名</td>
<td style="text-align:center">move</td>
</tr>
<tr>
<td style="text-align:center">basename</td>
<td style="text-align:center">取得文件名</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">dirname</td>
<td style="text-align:center">取得目录名</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">cat</td>
<td style="text-align:center">由第一行开始显示文件类容</td>
<td style="text-align:center">concatenate files and print.不是很清楚</td>
</tr>
<tr>
<td style="text-align:center">tac</td>
<td style="text-align:center">从最后一行开始显示</td>
<td style="text-align:center">cat的倒写</td>
</tr>
<tr>
<td style="text-align:center">nl</td>
<td style="text-align:center">显示文件并输出行号</td>
<td style="text-align:center">number line of files</td>
</tr>
<tr>
<td style="text-align:center">more</td>
<td style="text-align:center">一页一页显示</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">less</td>
<td style="text-align:center">类似与more，可以向前翻页</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">head</td>
<td style="text-align:center">只看头几行</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">tail</td>
<td style="text-align:center">只看结尾几行</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">od</td>
<td style="text-align:center">以8进制方式读取文件</td>
<td style="text-align:center">octal dump files</td>
</tr>
<tr>
<td style="text-align:center">touch</td>
<td style="text-align:center">创建新文件，或者更改文件时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">umask</td>
<td style="text-align:center">设置或访问新建文件或目录的默认权限</td>
</tr>
<tr>
<td style="text-align:center">which</td>
<td style="text-align:center">在当前用户的PATH中寻找命令文件,找不到cd命令，应为是bash内置的</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">whereis</td>
<td style="text-align:center">根据数据库，查找特定的文件,-bmsu</td>
<td style="text-align:center">where is</td>
</tr>
<tr>
<td style="text-align:center">locate</td>
<td style="text-align:center">根据数据库，查找特定的文件,-ir忽略大小写，使用正则</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">updatedb</td>
<td style="text-align:center">更新locate命令依赖的数据库</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">find</td>
<td style="text-align:center">更加强大的查找命令</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">df</td>
<td style="text-align:center">查看目前挂载的设备</td>
<td style="text-align:center">disk filesystem usage</td>
</tr>
<tr>
<td style="text-align:center">du</td>
<td style="text-align:center">查看当前目录下文件与目录的信息</td>
<td style="text-align:center">Directory usage</td>
</tr>
<tr>
<td style="text-align:center">dumpe2fs</td>
<td style="text-align:center">查看某一个文件系统的所有情况</td>
<td style="text-align:center">dump ext2/ext3/ext4 filesystem information</td>
</tr>
<tr>
<td style="text-align:center">fdisk</td>
<td style="text-align:center">对磁盘进行管理，分区操作等，不能处理&gt;2T的磁盘</td>
<td style="text-align:center">manipulate disk partition table</td>
</tr>
<tr>
<td style="text-align:center">mkfs,mke2fs</td>
<td style="text-align:center">磁盘格式化,指定分区信息</td>
<td style="text-align:center">make file system</td>
</tr>
<tr>
<td style="text-align:center">fask</td>
<td style="text-align:center">磁盘检查,检查文件系统是否出错</td>
<td style="text-align:center">file system check</td>
</tr>
<tr>
<td style="text-align:center">badblocks</td>
<td style="text-align:center">检查扇区有没有坏道</td>
<td style="text-align:center">search a device for bad blocks</td>
</tr>
<tr>
<td style="text-align:center">mount</td>
<td style="text-align:center">挂载设备</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">umount</td>
<td style="text-align:center">弹出设备</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">mknod</td>
<td style="text-align:center">将设备文件，设置成外部输入设备，存储设备等，设置设备文件的major,minor</td>
<td style="text-align:center">make block or character special files</td>
</tr>
<tr>
<td style="text-align:center">e2label</td>
<td style="text-align:center">设置设备的卷标</td>
<td style="text-align:center">Change the label on an ext2/ext3/ext4 filesystem</td>
</tr>
<tr>
<td style="text-align:center">tune2fs</td>
<td style="text-align:center">修改卷标，升级文件系统，读super block数据</td>
<td style="text-align:center">adjust tunable filesystem parameters on ext2/ext3/ext4</td>
</tr>
<tr>
<td style="text-align:center">hdparm</td>
<td style="text-align:center">设置IDE借口的磁盘的高级参数</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">parted</td>
<td style="text-align:center">对高于2TB容量的硬盘进行分区</td>
</tr>
</tbody>
</table>
<p><strong>update in 2016-05-17</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是为了通过命令的目的或者全名，理解记忆各个命令的功能&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://thinerzq.com/categories/linux/"/>
    
    
      <category term="linux order" scheme="http://thinerzq.com/tags/linux-order/"/>
    
  </entry>
  
  <entry>
    <title>linux杂记</title>
    <link href="http://thinerzq.com/2016/05/06/linux%E6%9D%82%E8%AE%B0/"/>
    <id>http://thinerzq.com/2016/05/06/linux杂记/</id>
    <published>2016-05-06T05:31:06.000Z</published>
    <updated>2016-05-29T13:16:59.834Z</updated>
    
    <content type="html"><![CDATA[<p>linux 中的一些琐碎知识点<br><a id="more"></a></p>
<h1 id="目录标识："><a href="#目录标识：" class="headerlink" title="目录标识："></a>目录标识：</h1><table>
<thead>
<tr>
<th style="text-align:center">目录</th>
<th style="text-align:center">意思</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">当前目录</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">上一层目录</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">前一个工作目录</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">用户所在主目录</td>
</tr>
<tr>
<td style="text-align:center">~account</td>
<td style="text-align:center">account所在主目录</td>
</tr>
</tbody>
</table>
<h1 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h1><blockquote>
<p><strong> -rw-r–r– l username group size last modify time filename </strong><br>这里的文件时间，指的是mtime,所谓的文件时间还包括 ctime, actime</p>
</blockquote>
<h3 id="系统挂载"><a href="#系统挂载" class="headerlink" title="系统挂载"></a>系统挂载</h3><ol>
<li>根目录必须挂载，而且一定要先于其他mount point被挂载进来</li>
<li>其他挂载点必须为已经新建的目录</li>
<li>所有的挂载点/分区，在同一时间只能挂载一次</li>
<li>如果要卸载，必须先将工作目录，移除到挂载点之外。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux 中的一些琐碎知识点&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://thinerzq.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://thinerzq.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux 文件与目录权限问题</title>
    <link href="http://thinerzq.com/2016/05/06/linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
    <id>http://thinerzq.com/2016/05/06/linux-文件与目录权限问题/</id>
    <published>2016-05-06T05:02:31.000Z</published>
    <updated>2016-05-30T16:02:29.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">读取文件类容</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">编辑，新增，或者修改文件类容（不能删除）</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">可执行，不代表能执行成功</td>
</tr>
</tbody>
</table>
<h1 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h1><table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">读取目录结构列表的权限，查询该目录下的文件名列表，只能用ls看文件名，文件的其他属性看不到</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">更改该目录下面的目录结构列表，包括（新建，删除，重命名，转移）该目录下面的文件或目录</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">能够进入该目录工作，可以cd进入这个目录</td>
</tr>
</tbody>
</table>
<p>要将目录开放给任何人，一般要具有rx权限</p>
<a id="more"></a>
<h1 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h1><p>新建文件和目录的时候，他们的默认权限是由umask指定的，<br>umask的值是多少，那么新建的目录或者用户就没有这个权限，同时新建的文件是没有x权限的，而新建的目录有x权限。</p>
<h1 id="文件隐藏属性chattr-lsattr"><a href="#文件隐藏属性chattr-lsattr" class="headerlink" title="文件隐藏属性chattr,lsattr"></a>文件隐藏属性chattr,lsattr</h1><p>chattr -i filename 设置文件不可删除<br>lsattr a filename 显示我你见影藏属性</p>
<!--# 文件的特殊权限 SUID,SGID,SBIT-->
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;File&quot;&gt;&lt;a href=&quot;#File&quot; class=&quot;headerlink&quot; title=&quot;File&quot;&gt;&lt;/a&gt;File&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;权限&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;r&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;读取文件类容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;w&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;编辑，新增，或者修改文件类容（不能删除）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;x&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;可执行，不代表能执行成功&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;Directory&quot;&gt;&lt;a href=&quot;#Directory&quot; class=&quot;headerlink&quot; title=&quot;Directory&quot;&gt;&lt;/a&gt;Directory&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;权限&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;r&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;读取目录结构列表的权限，查询该目录下的文件名列表，只能用ls看文件名，文件的其他属性看不到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;w&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;更改该目录下面的目录结构列表，包括（新建，删除，重命名，转移）该目录下面的文件或目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;x&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;能够进入该目录工作，可以cd进入这个目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;要将目录开放给任何人，一般要具有rx权限&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://thinerzq.com/categories/linux/"/>
    
    
      <category term="linux file permission" scheme="http://thinerzq.com/tags/linux-file-permission/"/>
    
  </entry>
  
  <entry>
    <title>多线程知识点总结</title>
    <link href="http://thinerzq.com/2016/05/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://thinerzq.com/2016/05/04/多线程知识点总结/</id>
    <published>2016-05-04T01:08:06.000Z</published>
    <updated>2016-05-13T14:22:17.518Z</updated>
    
    <content type="html"><![CDATA[<p>java多线程中一些零碎的知识点总结</p>
<a id="more"></a>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>它在线程类任意位置让线程阻塞，和Thread.suspend()相比，弥补了resume()提前发生，导致线程无法继续执行的情况。和Object.wait()相比，它不需要先获得对象的锁，也不会跑出InterruptedException异常，<br>方法：<br>part();<br>parkNanos()<br>parkUntil();<br>part(Object);</p>
<p>LockSupport为每一个线程准备了一个许可，默认不可用，如果可用park()函数会返回，并消费这个许可，如果不可用就会阻塞，unpark()会使得这个许可可用。</p>
<p>park()的挂起状态不会像suspend()那么给出令人费解的Runnable状态，而是WAITING状态，还会标注是part()引起的。<br>还可以使用park(Object) 在当前线程中设置一个阻塞对象，用于分析线程阻塞用。</p>
<p>LockSupport还能支持中断影响，但是LockSupport.park()不会跑出InterruptedException 异常，只会默默返回。配合上Thread.interrupted()方法可以获得中断标记，执行中断处理。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p> 使用submit(Runnable)方法执行任务，线程池可能会吃掉程序跑出的异常，改用execute(Runnable)方法执行任务，或者Future future = submit(Runnable);future.get()执行任务。另外还可以扩展线程池，包装一个新的Runnable扑捉异常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java多线程中一些零碎的知识点总结&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://thinerzq.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://thinerzq.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java线程池的实现总结</title>
    <link href="http://thinerzq.com/2016/05/03/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://thinerzq.com/2016/05/03/java线程池的实现总结/</id>
    <published>2016-05-03T08:19:38.000Z</published>
    <updated>2016-05-03T09:53:21.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-和Runnable-的区别"><a href="#Thread-和Runnable-的区别" class="headerlink" title="Thread 和Runnable 的区别"></a>Thread 和Runnable 的区别</h1><p>学了这么久的多线程，始终有一点迷惑</p>
<blockquote>
<p>往线程池里面提交的时候，提交的是一个实现了Runnable接口的对象，本来提交的时候就是一个Runnable,那么怎么实现线程复用。</p>
</blockquote>
<p>产生这个迷惑的原因是没有弄明白Thread 和Runnable的区别。</p>
<p>java中真正的线程执行类是Thread  </p>
<p>Runnable（可运行的）只是一个接口，中间定义了run()方法，实现了这个接口的类，实现了run()方法，通过把这个实现类交给Thread对象去运行。  </p>
<p>thread.start()方法里调用了start0()这个native函数来实现.start()函数的注释上写着，java虚拟机会自动调用这个线程的run()方法，然并卵。  </p>
<p>请看thread里面的run()怎么写的，如果target(一个Runnable实例对象)不为空，他就调用其中的run()方法。我相信start0()这个native方法里面肯定取调用了run()方法。见如下的代码</p>
<p>也可以把Runnable理解成只是JDK给出的一个标识性接口而已。看网上说了那么多都是浮云。<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Causes this thread to begin execution; the Java Virtual Machine</div><div class="line">    * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</div><div class="line">    * &lt;p&gt;</div><div class="line">    * The result is that two threads are running concurrently: the</div><div class="line">    * current thread (which returns from the call to the</div><div class="line">    * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</div><div class="line">    * &lt;code&gt;run&lt;/code&gt; method).</div><div class="line">    * &lt;p&gt;</div><div class="line">    * It is never legal to start a thread more than once.</div><div class="line">    * In particular, a thread may not be restarted once it has completed</div><div class="line">    * execution.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</div><div class="line">    *               started.</div><div class="line">    * <span class="doctag">@see</span>        #run()</div><div class="line">    * <span class="doctag">@see</span>        #stop()</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * This method is not invoked for the main method thread or "system"</div><div class="line">         * group threads created/set up by the VM. Any new functionality added</div><div class="line">         * to this method in the future may have to also be added to the VM.</div><div class="line">         *</div><div class="line">         * A zero status value corresponds to state "NEW".</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line"></div><div class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></div><div class="line">         * so that it can be added to the group's list of threads</div><div class="line">         * and the group's unstarted count can be decremented. */</div><div class="line">        group.add(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            start0();</div><div class="line">            started = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!started) &#123;</div><div class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</div><div class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></div><div class="line">                  it will be passed up the call stack */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * If this thread was constructed using a separate</div><div class="line">     * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</div><div class="line">     * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called;</div><div class="line">     * otherwise, this method does nothing and returns.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span>     #start()</div><div class="line">     * <span class="doctag">@see</span>     #stop()</div><div class="line">     * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">            target.run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="自己写一个线程池"><a href="#自己写一个线程池" class="headerlink" title="自己写一个线程池"></a>自己写一个线程池</h1><p>大家都知道要用线程池，也有一些讲Executor框架的博客之类的，咋一看理解起来不成问题，自己准备参照网上的一些例子，写一个最简单的线程池</p>
<blockquote>
<p>线程池说白了，一个List池子里面有一堆的<font color="red">Thread对象</font>，然后提交一个<font color="red">Runable对象</font>,这时候，<font color="red">从List池子里面取一个Thread对象来调用Runnable对象的run()方法而已</font>!   Thread才是真正的线程对象，他的创建才是需要开销的。</p>
</blockquote>
<h2 id="线程池类"><a href="#线程池类" class="headerlink" title="线程池类"></a>线程池类</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Intellij IDEA</div><div class="line"> * Date: 16-5-3</div><div class="line"> * Time: 下午2:39</div><div class="line"> * User: thinerzq</div><div class="line"> * Github: https://www.github.com/ThinerZQ</div><div class="line"> * Blog: http://www.thinerzq.me</div><div class="line"> * Email: thinerzq@gmail.com</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义线程池，学习线程池的原理</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//单例模式</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyThreadPool instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//空闲线程队列</span></div><div class="line">    <span class="keyword">private</span> List&lt;MyThread&gt; idelThreadList;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;MyThread&gt; workerThreadList;</div><div class="line"></div><div class="line">    <span class="comment">//总的线程数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadCount;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown=<span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadPool</span><span class="params">()</span></span>&#123;</div><div class="line">        idelThreadList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">        workerThreadList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">        threadCount = <span class="number">0</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//单例模式获取线程池实例</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> MyThreadPool <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</div><div class="line">            instance = <span class="keyword">new</span> MyThreadPool();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">submit</span><span class="params">(Runnable target)</span></span>&#123;</div><div class="line"></div><div class="line">        MyThread workThread = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (idelThreadList.size() &gt; <span class="number">0</span>)&#123;</div><div class="line"></div><div class="line">            <span class="comment">//随机取一个线程执行任务,这里取第1个空闲线程</span></div><div class="line">            workThread = idelThreadList.get(<span class="number">0</span>);</div><div class="line">            idelThreadList.remove(workThread);</div><div class="line">            <span class="comment">//开始工作了</span></div><div class="line">            workThread.setTarget(target);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="comment">//创建新的线程来执行任务</span></div><div class="line">            threadCount ++;</div><div class="line">            workThread = <span class="keyword">new</span> MyThread(instance,target);</div><div class="line">            workerThreadList.add(workThread);</div><div class="line">            workThread.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</div><div class="line">        isShutdown = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idelThreadList.size(); i++) &#123;</div><div class="line">            idelThreadList.get(i).shutdown();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rePushToIdeaThreadList</span><span class="params">(MyThread myThread)</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isShutdown)&#123;</div><div class="line">            idelThreadList.add(myThread);</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">            myThread.shutdown();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pullToWorkThreadList</span><span class="params">(MyThread myThread)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isShutdown)&#123;</div><div class="line">            workerThreadList.remove(myThread);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            myThread.shutdown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//等到线程池执行完所有任务，不一定准确，没想到好的实现方式</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitTermination</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (workerThreadList.size()!=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span> (workerThreadList.size() == <span class="number">0</span>)&#123;</div><div class="line">                Thread.sleep(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> threadCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="线程池中的线程类"><a href="#线程池中的线程类" class="headerlink" title="线程池中的线程类"></a>线程池中的线程类</h2><p>为什么需要定义自己的线程？ 因为线程池里面的线程，执行完提交的任务之后，还需要复用（不能run()方法执行完就结束了）。所以需要自定线程来管理当前线程的生命周期。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Intellij IDEA</div><div class="line"> * Date: 16-5-3</div><div class="line"> * Time: 下午2:42</div><div class="line"> * User: thinerzq</div><div class="line"> * Github: https://www.github.com/ThinerZQ</div><div class="line"> * Blog: http://www.thinerzq.me</div><div class="line"> * Email: thinerzq@gmail.com</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//当前线程所在的线程池</span></div><div class="line">    <span class="keyword">private</span> MyThreadPool pool;</div><div class="line"></div><div class="line">    <span class="comment">//当前线程需要执行的任务</span></div><div class="line">    <span class="keyword">private</span> Runnable target;</div><div class="line"></div><div class="line">    <span class="comment">//当前线程是不是结束了</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShutDown = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">//当前线程是不是空闲的</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isIdle = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(MyThreadPool myThreadPool,Runnable target)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.pool = myThreadPool;</div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//当前线程的处理逻辑,只要当前现成没有结束，就不退出</span></div><div class="line">        <span class="keyword">while</span> (!isShutDown)&#123;</div><div class="line"></div><div class="line">            <span class="comment">//</span></div><div class="line">            isIdle = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="comment">//运行任务，单纯的调用target的run()方法</span></div><div class="line">                target.run();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            isIdle = <span class="keyword">true</span>;</div><div class="line">            pool.pullToWorkThreadList(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//线程运行任务结束了，重新放入线程池</span></div><div class="line">                pool.rePushToIdeaThreadList(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</div><div class="line">                    <span class="comment">//线程空闲，需要等待任务到来</span></div><div class="line">                    wait();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">                <span class="comment">//放入线程池失败</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            isIdle = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Runnable target)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">        notify();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.isShutDown = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//要关闭的时候，要把wait()的本线程唤醒，然后再让其运行完。</span></div><div class="line">        notify();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIdle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isIdle;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要上面两个类，一个最基本的线程池就建立好了（每次提交任务的时候，如果有空闲线程就使用空闲线程，否则创建新的线程），每次只要使用submit()方法提交一个任务就好了。</p>
<p>下面使用一个例子，来测试一下</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="两个任务类"><a href="#两个任务类" class="headerlink" title="两个任务类"></a>两个任务类</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是任务A,现在被执行"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是任务B,现在被执行"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Client类"><a href="#Client类" class="headerlink" title="Client类"></a>Client类</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            Runnable runnable = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span> )</div><div class="line">                runnable = <span class="keyword">new</span> TaskThreadA();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                runnable = <span class="keyword">new</span> TaskThreadB();</div><div class="line">            MyThreadPool.getInstance().submit(runnable);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//等待所有任务执行完成</span></div><div class="line">        MyThreadPool.getInstance().awaitTermination();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"time consume : "</span>+ (end-start)+<span class="string">" ms"</span>);</div><div class="line">        System.out.println(<span class="string">"一共启动了: "</span>+MyThreadPool.getInstance().getThreadCount()+<span class="string">" 个线程"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p> 我们提交了100个任务，可是最后只启动了42个线程，这就是线程池。Executor框架中的几种线程池都差不多是这种套路，只是控制策略根加的多。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">...</div><div class="line">我是任务B,现在被执行</div><div class="line">我是任务B,现在被执行</div><div class="line">我是任务A,现在被执行</div><div class="line">我是任务B,现在被执行</div><div class="line">我是任务A,现在被执行</div><div class="line">我是任务A,现在被执行</div><div class="line">我是任务B,现在被执行</div><div class="line">我是任务A,现在被执行</div><div class="line">我是任务B,现在被执行</div><div class="line">我是任务B,现在被执行</div><div class="line">我是任务A,现在被执行</div><div class="line">我是任务B,现在被执行</div><div class="line">我是任务A,现在被执行</div><div class="line">我是任务B,现在被执行</div><div class="line">我是任务A,现在被执行</div><div class="line">我是任务B,现在被执行</div><div class="line">time consume : 11 ms</div><div class="line">一共启动了: 42 个线程</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thread-和Runnable-的区别&quot;&gt;&lt;a href=&quot;#Thread-和Runnable-的区别&quot; class=&quot;headerlink&quot; title=&quot;Thread 和Runnable 的区别&quot;&gt;&lt;/a&gt;Thread 和Runnable 的区别&lt;/h1&gt;&lt;p&gt;学了这么久的多线程，始终有一点迷惑&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;往线程池里面提交的时候，提交的是一个实现了Runnable接口的对象，本来提交的时候就是一个Runnable,那么怎么实现线程复用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;产生这个迷惑的原因是没有弄明白Thread 和Runnable的区别。&lt;/p&gt;
&lt;p&gt;java中真正的线程执行类是Thread  &lt;/p&gt;
&lt;p&gt;Runnable（可运行的）只是一个接口，中间定义了run()方法，实现了这个接口的类，实现了run()方法，通过把这个实现类交给Thread对象去运行。  &lt;/p&gt;
&lt;p&gt;thread.start()方法里调用了start0()这个native函数来实现.start()函数的注释上写着，java虚拟机会自动调用这个线程的run()方法，然并卵。  &lt;/p&gt;
&lt;p&gt;请看thread里面的run()怎么写的，如果target(一个Runnable实例对象)不为空，他就调用其中的run()方法。我相信start0()这个native方法里面肯定取调用了run()方法。见如下的代码&lt;/p&gt;
&lt;p&gt;也可以把Runnable理解成只是JDK给出的一个标识性接口而已。看网上说了那么多都是浮云。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://thinerzq.com/categories/java/"/>
    
    
      <category term="线程池" scheme="http://thinerzq.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
